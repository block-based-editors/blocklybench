/**************************************\
*          Smooth Voxels               *
* Copyright (c) 2021 Samuel Van Egmond *
*           MIT License                *
*    https://smoothvoxels.glitch.me    *
\**************************************/
/* global AFRAME */
/* global THREE */
"use strict";var SVOX={clampColors:!1,models:{},MATSTANDARD:"standard",MATBASIC:"basic",MATLAMBERT:"lambert",MATPHONG:"phong",MATMATCAP:"matcap",MATTOON:"toon",MATNORMAL:"normal",FLAT:"flat",SMOOTH:"smooth",BOTH:"both",FRONT:"front",BACK:"back",DOUBLE:"double",_FACES:["nx","px","ny","py","nz","pz"],_VERTICES:{nx:[{x:0,y:0,z:0},{x:0,y:1,z:0},{x:0,y:1,z:1},{x:0,y:0,z:1}],px:[{x:1,y:0,z:1},{x:1,y:1,z:1},{x:1,y:1,z:0},{x:1,y:0,z:0}],ny:[{x:0,y:0,z:0},{x:0,y:0,z:1},{x:1,y:0,z:1},{x:1,y:0,z:0}],py:[{x:0,y:1,z:1},{x:0,y:1,z:0},{x:1,y:1,z:0},{x:1,y:1,z:1}],nz:[{x:1,y:0,z:0},{x:1,y:1,z:0},{x:0,y:1,z:0},{x:0,y:0,z:0}],pz:[{x:0,y:0,z:1},{x:0,y:1,z:1},{x:1,y:1,z:1},{x:1,y:0,z:1}]},_NEIGHBORS:{nx:{x:-1,y:0,z:0},px:{x:1,y:0,z:0},ny:{x:0,y:-1,z:0},py:{x:0,y:1,z:0},nz:{x:0,y:0,z:-1},pz:{x:0,y:0,z:1}},_FACEUVS:{nx:{u:"z",v:"y",order:[0,1,2,3],ud:1,vd:1,uo:0,vo:0},px:{u:"z",v:"y",order:[3,2,1,0],ud:-1,vd:1,uo:.75,vo:0},ny:{u:"x",v:"z",order:[0,1,2,3],ud:1,vd:1,uo:.75,vo:.5},py:{u:"x",v:"z",order:[1,0,3,2],ud:1,vd:-1,uo:.25,vo:1},nz:{u:"x",v:"y",order:[3,2,1,0],ud:-1,vd:1,uo:1,vo:0},pz:{u:"x",v:"y",order:[0,1,2,3],ud:1,vd:1,uo:.25,vo:0}}};let hasFloat32Array="undefined"!=typeof Float32Array;class Matrix{constructor(){let e=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];this.m=hasFloat32Array?new Float32Array(e):e}transformPoint(e){let t=this.m,s=t[12]*e.x+t[13]*e.y+t[14]*e.z+t[15],a=(t[0]*e.x+t[1]*e.y+t[2]*e.z+t[3])/s,r=(t[4]*e.x+t[5]*e.y+t[6]*e.z+t[7])/s,i=(t[8]*e.x+t[9]*e.y+t[10]*e.z+t[11])/s;e.x=a,e.y=r,e.z=i}transformVector(e){let t=this.m,s=t[0]*e.x+t[1]*e.y+t[2]*e.z,a=t[4]*e.x+t[5]*e.y+t[6]*e.z,r=t[8]*e.x+t[9]*e.y+t[10]*e.z;e.x=s,e.y=a,e.z=r}static identity(e){let t=(e=e||new Matrix).m;return t[0]=t[5]=t[10]=t[15]=1,t[1]=t[2]=t[3]=t[4]=t[6]=t[7]=t[8]=t[9]=t[11]=t[12]=t[13]=t[14]=0,e}static multiply(e,t,s){s=s||new Matrix;let a=e.m,r=t.m,i=s.m;return i[0]=a[0]*r[0]+a[1]*r[4]+a[2]*r[8]+a[3]*r[12],i[1]=a[0]*r[1]+a[1]*r[5]+a[2]*r[9]+a[3]*r[13],i[2]=a[0]*r[2]+a[1]*r[6]+a[2]*r[10]+a[3]*r[14],i[3]=a[0]*r[3]+a[1]*r[7]+a[2]*r[11]+a[3]*r[15],i[4]=a[4]*r[0]+a[5]*r[4]+a[6]*r[8]+a[7]*r[12],i[5]=a[4]*r[1]+a[5]*r[5]+a[6]*r[9]+a[7]*r[13],i[6]=a[4]*r[2]+a[5]*r[6]+a[6]*r[10]+a[7]*r[14],i[7]=a[4]*r[3]+a[5]*r[7]+a[6]*r[11]+a[7]*r[15],i[8]=a[8]*r[0]+a[9]*r[4]+a[10]*r[8]+a[11]*r[12],i[9]=a[8]*r[1]+a[9]*r[5]+a[10]*r[9]+a[11]*r[13],i[10]=a[8]*r[2]+a[9]*r[6]+a[10]*r[10]+a[11]*r[14],i[11]=a[8]*r[3]+a[9]*r[7]+a[10]*r[11]+a[11]*r[15],i[12]=a[12]*r[0]+a[13]*r[4]+a[14]*r[8]+a[15]*r[12],i[13]=a[12]*r[1]+a[13]*r[5]+a[14]*r[9]+a[15]*r[13],i[14]=a[12]*r[2]+a[13]*r[6]+a[14]*r[10]+a[15]*r[14],i[15]=a[12]*r[3]+a[13]*r[7]+a[14]*r[11]+a[15]*r[15],s}static transpose(e,t){t=t||new Matrix;let s=e.m,a=t.m;return a[0]=s[0],a[1]=s[4],a[2]=s[8],a[3]=s[12],a[4]=s[1],a[5]=s[5],a[6]=s[9],a[7]=s[13],a[8]=s[2],a[9]=s[6],a[10]=s[10],a[11]=s[14],a[12]=s[3],a[13]=s[7],a[14]=s[11],a[15]=s[15],t}static inverse(e,t){t=t||new Matrix;let s=e.m,a=t.m;a[0]=s[5]*s[10]*s[15]-s[5]*s[14]*s[11]-s[6]*s[9]*s[15]+s[6]*s[13]*s[11]+s[7]*s[9]*s[14]-s[7]*s[13]*s[10],a[1]=-s[1]*s[10]*s[15]+s[1]*s[14]*s[11]+s[2]*s[9]*s[15]-s[2]*s[13]*s[11]-s[3]*s[9]*s[14]+s[3]*s[13]*s[10],a[2]=s[1]*s[6]*s[15]-s[1]*s[14]*s[7]-s[2]*s[5]*s[15]+s[2]*s[13]*s[7]+s[3]*s[5]*s[14]-s[3]*s[13]*s[6],a[3]=-s[1]*s[6]*s[11]+s[1]*s[10]*s[7]+s[2]*s[5]*s[11]-s[2]*s[9]*s[7]-s[3]*s[5]*s[10]+s[3]*s[9]*s[6],a[4]=-s[4]*s[10]*s[15]+s[4]*s[14]*s[11]+s[6]*s[8]*s[15]-s[6]*s[12]*s[11]-s[7]*s[8]*s[14]+s[7]*s[12]*s[10],a[5]=s[0]*s[10]*s[15]-s[0]*s[14]*s[11]-s[2]*s[8]*s[15]+s[2]*s[12]*s[11]+s[3]*s[8]*s[14]-s[3]*s[12]*s[10],a[6]=-s[0]*s[6]*s[15]+s[0]*s[14]*s[7]+s[2]*s[4]*s[15]-s[2]*s[12]*s[7]-s[3]*s[4]*s[14]+s[3]*s[12]*s[6],a[7]=s[0]*s[6]*s[11]-s[0]*s[10]*s[7]-s[2]*s[4]*s[11]+s[2]*s[8]*s[7]+s[3]*s[4]*s[10]-s[3]*s[8]*s[6],a[8]=s[4]*s[9]*s[15]-s[4]*s[13]*s[11]-s[5]*s[8]*s[15]+s[5]*s[12]*s[11]+s[7]*s[8]*s[13]-s[7]*s[12]*s[9],a[9]=-s[0]*s[9]*s[15]+s[0]*s[13]*s[11]+s[1]*s[8]*s[15]-s[1]*s[12]*s[11]-s[3]*s[8]*s[13]+s[3]*s[12]*s[9],a[10]=s[0]*s[5]*s[15]-s[0]*s[13]*s[7]-s[1]*s[4]*s[15]+s[1]*s[12]*s[7]+s[3]*s[4]*s[13]-s[3]*s[12]*s[5],a[11]=-s[0]*s[5]*s[11]+s[0]*s[9]*s[7]+s[1]*s[4]*s[11]-s[1]*s[8]*s[7]-s[3]*s[4]*s[9]+s[3]*s[8]*s[5],a[12]=-s[4]*s[9]*s[14]+s[4]*s[13]*s[10]+s[5]*s[8]*s[14]-s[5]*s[12]*s[10]-s[6]*s[8]*s[13]+s[6]*s[12]*s[9],a[13]=s[0]*s[9]*s[14]-s[0]*s[13]*s[10]-s[1]*s[8]*s[14]+s[1]*s[12]*s[10]+s[2]*s[8]*s[13]-s[2]*s[12]*s[9],a[14]=-s[0]*s[5]*s[14]+s[0]*s[13]*s[6]+s[1]*s[4]*s[14]-s[1]*s[12]*s[6]-s[2]*s[4]*s[13]+s[2]*s[12]*s[5],a[15]=s[0]*s[5]*s[10]-s[0]*s[9]*s[6]-s[1]*s[4]*s[10]+s[1]*s[8]*s[6]+s[2]*s[4]*s[9]-s[2]*s[8]*s[5];let r=s[0]*a[0]+s[1]*a[4]+s[2]*a[8]+s[3]*a[12];for(let e=0;e<16;e++)a[e]/=r;return t}static scale(e,t,s,a){let r=(a=a||new Matrix).m;return r[0]=e,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=t,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[10]=s,r[11]=0,r[12]=0,r[13]=0,r[14]=0,r[15]=1,a}static translate(e,t,s,a){let r=(a=a||new Matrix).m;return r[0]=1,r[1]=0,r[2]=0,r[3]=e,r[4]=0,r[5]=1,r[6]=0,r[7]=t,r[8]=0,r[9]=0,r[10]=1,r[11]=s,r[12]=0,r[13]=0,r[14]=0,r[15]=1,a}static rotate(e,t,s,a,r){if(!e||!t&&!s&&!a)return Matrix.identity(r);let i=(r=r||new Matrix).m,o=Math.sqrt(t*t+s*s+a*a);e*=Math.PI/180,t/=o,s/=o,a/=o;let l=Math.cos(e),n=Math.sin(e),m=1-l;return i[0]=t*t*m+l,i[1]=t*s*m-a*n,i[2]=t*a*m+s*n,i[3]=0,i[4]=s*t*m+a*n,i[5]=s*s*m+l,i[6]=s*a*m-t*n,i[7]=0,i[8]=a*t*m-s*n,i[9]=a*s*m+t*n,i[10]=a*a*m+l,i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,r}static lookAtORIGINAL(e,t,s,a,r,i,o,l,n,m){let h=(m=m||new Matrix).m,c=e-a,u=t-r,x=s-i,p=Math.sqrt(c*c+u*u+x*x),f=l*(x/=p)-n*(u/=p),g=n*(c/=p)-o*x,y=o*u-l*c,d=u*(y/=p=Math.sqrt(f*f+g*g+y*y))-x*(g/=p),v=x*(f/=p)-c*y,z=c*g-u*f;return d/=p=Math.sqrt(d*d+v*v+z*z),v/=p,z/=p,h[0]=f,h[1]=g,h[2]=y,h[3]=-(f*e+g*t+y*s),h[4]=d,h[5]=v,h[6]=z,h[7]=-(d*e+v*t+z*s),h[8]=c,h[9]=u,h[10]=x,h[11]=-(c*e+u*t+x*s),h[12]=0,h[13]=0,h[14]=0,h[15]=1,m}static lookAtTRYOUT(e,t,s,a){let r=(a=a||new Matrix).m,i=Math.sqrt(e*e+s*s);return r[0]=s/i,r[1]=0,r[2]=-e/i,r[3]=0,r[4]=e*t/i,r[5]=-i,r[6]=s*t/i,r[7]=0,r[8]=e,r[9]=t,r[10]=s,r[11]=0,r[12]=0,r[13]=0,r[14]=0,r[15]=1,a}static lookAt(e,t,s,a){let r=(a=a||new Matrix).m,i=Math.sqrt(e*e+s*s),o=i?e/i:1,l=i?s/i:0;return r[0]=e,r[1]=-l,r[2]=-s*o,r[3]=0,r[4]=t,r[5]=0,r[6]=i,r[7]=0,r[8]=s,r[9]=o,r[10]=-s*l,r[11]=0,r[12]=0,r[13]=0,r[14]=0,r[15]=1,a}rotation_matrix(e){}}class Planar{static parse(e){if(" "!==(e=" "+(e||"").toLowerCase())&&!/^(?!$)(\s+(?:none|-x|x|\+x|-y|y|\+y|-z|z|\+z|\s))+\s*$/.test(e))throw{name:"SyntaxError",message:`Planar expression '${e}' is only allowed to be 'none' or contain -x x +x -y y +y -z z +z.`};return{nx:e.includes("-x"),x:e.includes(" x"),px:e.includes("+x"),ny:e.includes("-y"),y:e.includes(" y"),py:e.includes("+y"),nz:e.includes("-z"),z:e.includes(" z"),pz:e.includes("+z")}}static toString(e){return((e.nx?" -x":"")+(e.x?" x":"")+(e.px?" +x":"")+(e.ny?" -y":"")+(e.y?" y":"")+(e.py?" +y":"")+(e.nz?" -z":"")+(e.z?" z":"")+(e.pz?" +z":"")).trim()}static combine(e,t,s){return e||t?e?t?e===t?e:{nx:e.nx||t.nx,x:e.x||t.x,px:e.px||t.px,ny:e.ny||t.ny,y:e.y||t.y,py:e.py||t.py,nz:e.nz||t.nz,z:e.z||t.z,pz:e.pz||t.pz}:e:t:s}}class BoundingBox{get size(){return this.minX>this.maxX?{x:0,y:0,z:0}:{x:this.maxX-this.minX+1,y:this.maxY-this.minY+1,z:this.maxZ-this.minZ+1}}contructor(){this.reset()}reset(){this.minX=Number.POSITIVE_INFINITY,this.minY=Number.POSITIVE_INFINITY,this.minZ=Number.POSITIVE_INFINITY,this.maxX=Number.NEGATIVE_INFINITY,this.maxY=Number.NEGATIVE_INFINITY,this.maxZ=Number.NEGATIVE_INFINITY}set(e,t,s){this.minX=Math.min(this.minX,e),this.minY=Math.min(this.minY,t),this.minZ=Math.min(this.minZ,s),this.maxX=Math.max(this.maxX,e),this.maxY=Math.max(this.maxY,t),this.maxZ=Math.max(this.maxZ,s)}}class Voxel{constructor(e){this.color=e,this.material=e.material,this.faces={},this.visible=!0}dispose(){this.color=null,this.material=null,this.faces=null}}class VoxelMatrix{get minX(){return this.bounds.minX}get minY(){return this.bounds.minY}get minZ(){return this.bounds.minZ}get maxX(){return this.bounds.maxX}get maxY(){return this.bounds.maxY}get maxZ(){return this.bounds.maxZ}get size(){return this.minX>this.maxX?{x:0,y:0,z:0}:{x:this.maxX-this.minX+1,y:this.maxY-this.minY+1,z:this.maxZ-this.minZ+1}}get count(){return this._count}constructor(){this.bounds=new BoundingBox,this._voxels=[],this._count=0,this.prepareForWrite()}reset(){this.forEach(function(e){e.reset},this,!0),this.bounds.reset(),this._voxels=[],this._count=0}setVoxel(e,t,s,a){if(!(a instanceof Voxel))throw new Error("setVoxel requires a Voxel set to an existing color of a material of this model.");this.bounds.set(e,t,s),a.material.bounds.set(e,t,s),a.x=e,a.y=t,a.z=s;let r=this._voxels[s+1e6];r||(r=[],this._voxels[s+1e6]=r);let i=r[t+1e6];i||(i=[],r[t+1e6]=i),i[e+1e6]||this._count++,i[e+1e6]=a}clearVoxel(e,t,s){let a=this._voxels[s+1e6];if(a&&(a=a[t+1e6])){let t=a[e+1e6];t&&(t.color--,this._count++,a.splice(e,1))}}getVoxel(e,t,s){let a=this._voxels[s+1e6];return a&&(a=a[t+1e6])?a[e+1e6]:null}forEach(e,t,s){for(let a in this._voxels){let r=this._voxels[a];for(let a in r){let i=r[a];for(let a in i){let r=i[a];if(r&&(!s||r.visible)){if(!0===e.apply(t,[r]))return}}}}}forEachInBoundary(e,t){for(let s=this.bounds.minZ;s<=this.bounds.maxZ;s++)for(let a=this.bounds.minY;a<=this.bounds.maxY;a++)for(let r=this.bounds.minX;r<=this.bounds.maxX;r++){if(!0===e.apply(t,[this.getVoxel(r,a,s)]))return}}prepareForWrite(){this.bounds.reset(),this._count=0,this.forEach(function(e){this.setVoxel(e.x,e.y,e.z,e)},this)}}const clamp=(e,t,s)=>Math.min(Math.max(e,t),s);class Color{static fromHex(e){let t=new Color;return t._set(e),t.id="",t.exId=null,t.count=0,t}static fromRgb(e,t,s){e=Math.round(255*clamp(e,0,1)),t=Math.round(255*clamp(t,0,1)),s=Math.round(255*clamp(s,0,1));let a="#"+(e<16?"0":"")+e.toString(16)+(t<16?"0":"")+t.toString(16)+(s<16?"0":"")+s.toString(16);return Color.fromHex(a)}clone(){let e=new Color;return e._color=this._color,e.r=this.r,e.g=this.g,e.b=this.b,e._material=this._material,e}multiply(e){return e instanceof Color?Color.fromRgb(this.r*e.r,this.g*e.g,this.b*e.b):Color.fromRgb(this.r*e,this.g*e,this.b*e)}add(...e){let t=this.r+e.reduce((e,t)=>e+t.r,0),s=this.g+e.reduce((e,t)=>e+t.g,0),a=this.b+e.reduce((e,t)=>e+t.b,0);return Color.fromRgb(t,s,a)}_setMaterial(e){if(void 0!==this._material)throw"A Color can only be added once.";this._material=e,this.count=0}get material(){return this._material}_set(e){let t=e;if(("string"==typeof t||t instanceof String)&&(t=t.trim().toUpperCase()).match(/^#([0-9a-fA-F]{3}|#?[0-9a-fA-F]{6})$/)){t=t.replace("#",""),this._color="#"+t,3===t.length&&(t=t[0]+t[0]+t[1]+t[1]+t[2]+t[2]);let e=parseInt(t,16);return this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,void(this.b=(255&e)/255)}throw{name:"SyntaxError",message:`Color ${e} is not a hexadecimal color of the form #000 or #000000.`}}toString(){return this._color}}class BaseMaterial{constructor(e,t,s,a,r,i,o,l,n,m,h,c,u,x,p,f,g,y,d,v,z,_){switch(e=e||SVOX.MATSTANDARD){case SVOX.MATSTANDARD:case SVOX.MATBASIC:case SVOX.MATLAMBERT:case SVOX.MATPHONG:case SVOX.MATTOON:case SVOX.MATMATCAP:case SVOX.MATNORMAL:break;default:throw{name:"SyntaxError",message:`Unknown material type '${e}'.`}}if(this.type=e,(c&&c.cube||u&&u.cube||x&&x.cube||p&&p.cube||f&&f.cube)&&(-1!==y||-1!==d))throw{name:"SyntaxError",message:"Cube textures can not be combined with maptransform"};this.index=0,this.roughness="number"==typeof t?t:1,this.metalness="number"==typeof s?s:0,this.opacity="number"==typeof a?a:1,this.alphaTest="number"==typeof r?r:0,this.transparent=!!i,this.wireframe=!!o,this.side=l||"front",["front","back","double"].includes(this.side)||(this.side="front"),this.setEmissive(n,m),this.fog="boolean"!=typeof h||h,this.map=c,this.normalMap=u,this.roughnessMap=x,this.metalnessMap=p,this.emissiveMap=f,this.matcap=g,this.mapTransform={uscale:y||-1,vscale:d||-1,uoffset:v||0,voffset:z||0,rotation:_||0},this.aoActive=!1,this._colors=[]}get baseId(){return`${this.type}|${this.roughness}|${this.metalness}|`+`${this.opacity}|${this.alphaTest}|${this.wireframe?1:0}|${this.side}|`+(this.emissive?`${this.emissive.color}|${this.emissive.intensity}|`:"||")+`${this.fog?1:0}|`+(this.map?`${this.map.id}|`:"|")+(this.normalMap?`${this.normalMap.id}|`:"|")+(this.roughnessMap?`${this.roughnessMap.id}|`:"|")+(this.metalnessMap?`${this.metalnessMap.id}|`:"|")+(this.emissiveMap?`${this.emissiveMap.id}|`:"|")+(this.matcap?`${this.matcap.id}|`:"|")+`${this.mapTransform.uscale}|${this.mapTransform.vscale}|`+`${this.mapTransform.uoffset}|${this.mapTransform.voffset}|`+`${this.mapTransform.rotation}`}get isTransparent(){return this.transparent||this.opacity<1}setEmissive(e,t){this._emissive=void 0!==e&&"#000"!==e&&"#000000"!==e&&t?{color:Color.fromHex(e),intensity:t}:void 0}get emissive(){return this._emissive}get colors(){return this._colors}get colorCount(){return this._colors.length}get colorUsageCount(){return this._colors.reduce((e,t)=>e+t.count,0)}}class Material{constructor(e,t,s){this._baseMaterial=e,this.lighting=t,this.fade=!!s,this._deform=void 0,this._warp=void 0,this._scatter=void 0,this._flatten=Planar.parse(""),this._clamp=Planar.parse(""),this._skip=Planar.parse(""),this._ao=void 0,this.lights=!0,this._colors=[],this.bounds=new BoundingBox}get baseId(){return this._baseMaterial.baseId}get index(){return this._baseMaterial.index}get colors(){return this._colors}get colorCount(){return this._baseMaterial.colorCount}get type(){return this._baseMaterial.type}get roughness(){return this._baseMaterial.roughness}get metalness(){return this._baseMaterial.metalness}get opacity(){return this._baseMaterial.opacity}get alphaTest(){return this._baseMaterial.alphaTest}get transparent(){return this._baseMaterial.transparent}get isTransparent(){return this._baseMaterial.isTransparent}get emissive(){return this._baseMaterial.emissive}get side(){return this._baseMaterial.side}get fog(){return this._baseMaterial.fog}get map(){return this._baseMaterial.map}get normalMap(){return this._baseMaterial.normalMap}get roughnessMap(){return this._baseMaterial.roughnessMap}get metalnessMap(){return this._baseMaterial.metalnessMap}get emissiveMap(){return this._baseMaterial.emissiveMap}get matcap(){return this._baseMaterial.matcap}get mapTransform(){return this._baseMaterial.mapTransform}setDeform(e,t,s){e=Math.max(null==e?1:e,0),t=null==t?1:t,s=null==s?1:s,this._deform=e>0&&0!==t?{count:e,strength:t,damping:s}:void 0}get deform(){return this._deform}setWarp(e,t){e=void 0===e?1:Math.abs(e),t=void 0===t?1:Math.abs(t),this._warp=e>.001&&t>.001?{amplitude:e,frequency:t}:void 0}get warp(){return this._warp}set scatter(e){0===e&&(e=void 0),this._scatter=Math.abs(e)}get scatter(){return this._scatter}set flatten(e){this._flatten=Planar.parse(e)}get flatten(){return Planar.toString(this._flatten)}set clamp(e){this._clamp=Planar.parse(e)}get clamp(){return Planar.toString(this._clamp)}set skip(e){this._skip=Planar.parse(e)}get skip(){return Planar.toString(this._skip)}setAo(e){this._ao=e}get ao(){return this._ao}set aoSides(e){this._aoSides=Planar.parse(e)}get aoSides(){return Planar.toString(this._aoSides)}get colors(){return this._colors}addColorHEX(e){return this.addColor(Color.fromHex(e))}addColorRGB(e,t,s){return this.addColor(Color.fromRgb(e,t,s))}addColor(e){if(!(e instanceof Color))throw"addColor requires a Color object, e.g. material.addColor(Color.fromHex('#FFFFFF'))";return e._setMaterial(this),this._colors.push(e),this._baseMaterial._colors.push(e),e}}class MaterialList{constructor(){this.baseMaterials=[],this.materials=[]}createMaterial(e,t,s,a,r,i,o,l,n,m,h,c,u,x,p,f,g,y,d,v,z,_,M,S){let b=new BaseMaterial(e,s,a,i,o,l,n,m,h,c,u,x,p,f,g,y,d,v,z,_,M,S),E=b.baseId,C=this.baseMaterials.find(e=>e.baseId===E);C?b=C:this.baseMaterials.push(b);let T=new Material(b,t,r);return this.materials.push(T),T}forEach(e,t,s){s?this.baseMaterials.foreach(e,t):this.materials.forEach(e,t)}find(e){return this.materials.find(e)}findColorByExId(e){let t=null;return this.forEach(function(s){t||(t=s.colors.find(t=>t.exId===e))},this),t}}SVOX.Noise=function(){let e=[];for(let t=0;t<256;t++)e[t]=Math.floor(256*Math.random()),e[t+256]=e[t];function t(e){return e*e*e*(e*(6*e-15)+10)}function s(e,t,s){return t+e*(s-t)}function a(e,t,s,a){let r=15&e,i=r<8?t:s,o=r<4?s:12==r||14==r?t:a;return(0==(1&r)?i:-i)+(0==(2&r)?o:-o)}return{noise:function(r,i,o){let l=Math.floor(r),n=Math.floor(i),m=Math.floor(o),h=255&l,c=255&n,u=255&m,x=(r-=l)-1,p=(i-=n)-1,f=(o-=m)-1,g=t(r),y=t(i),d=t(o),v=e[h]+c,z=e[v]+u,_=e[v+1]+u,M=e[h+1]+c,S=e[M]+u,b=e[M+1]+u;return s(d,s(y,s(g,a(e[z],r,i,o),a(e[S],x,i,o)),s(g,a(e[_],r,p,o),a(e[b],x,p,o))),s(y,s(g,a(e[z+1],r,i,f),a(e[S+1],x,i,o-1)),s(g,a(e[_+1],r,p,f),a(e[b+1],x,p,f))))}}};class Deformer{static changeShape(e,t){switch(t){case"sphere":Deformer._circularDeform(e,1,1,1);break;case"cylinder-x":Deformer._circularDeform(e,0,1,1);break;case"cylinder-y":Deformer._circularDeform(e,1,0,1);break;case"cylinder-z":Deformer._circularDeform(e,1,1,0)}}static _circularDeform(e,t,s,a){let r=(e.voxels.minX+e.voxels.maxX)/2+.5,i=(e.voxels.minY+e.voxels.maxY)/2+.5,o=(e.voxels.minZ+e.voxels.maxZ)/2+.5;e.forEachVertex(function(e){let l=e.x-r,n=e.y-i,m=e.z-o,h=Math.max(Math.abs(l*t),Math.abs(n*s),Math.abs(m*a)),c=Math.sqrt(l*l*t+n*n*s+m*m*a);if(0===c)return;let u=h/c;e.newPos.x=l*(1-t+t*u)+r,e.newPos.y=n*(1-s+s*u)+i,e.newPos.z=m*(1-a+a*u)+o,e.newPos.set=!0,e.ring=h},this),Deformer._repositionChangedVertices(e,!0),Deformer._markEquidistantFaces(e)}static _markEquidistantFaces(e){e.voxels.forEach(function(e){for(let t in e.faces){let s=e.faces[t];if(s.skipped)continue;s.equidistant=!0;let a=s.vertices[0].ring;for(let e=1;e<4;e++){if(s.vertices[e].ring!==a){s.equidistant=!1;break}}}},this)}static maximumDeformCount(e){let t=0;return e.materials.forEach(function(e){e.deform&&(t=Math.max(t,e.deform.count))}),t}static deform(e,t){for(let s=0;s<t;s++)e.forEachVertex(function(e){if(e.deform&&e.deform.count>s){let t=e.links;if(t.length>0){let a=0,r=0,i=0;for(let e=0;e<t.length;e++)a+=t[e].x,r+=t[e].y,i+=t[e].z;let o=a/t.length-e.x,l=r/t.length-e.y,n=i/t.length-e.z,m=Math.pow(e.deform.damping,s)*e.deform.strength;0!==m&&(e.newPos.x=e.x+o*m,e.newPos.y=e.y+l*m,e.newPos.z=e.z+n*m,e.newPos.set=!0)}}},this),Deformer._repositionChangedVertices(e)}static warpAndScatter(e){let t=SVOX.Noise().noise,s=e.voxels,a=e._tile;e.forEachVertex(function(e){if(a.nx&&e.x<s.minX+.1||a.px&&e.x>s.maxX+.9||a.ny&&e.y<s.minY+.1||a.py&&e.y>s.maxY+.9||a.nz&&e.z<s.minZ+.1||a.pz&&e.z>s.maxZ+.9)return;let r=e.warp?e.warp.amplitude:0,i=e.warp?e.warp.frequency:0,o=e.scatter||0;if(r||o){let s=0,a=0,l=0;r&&(s=t((e.x+.19)*i,e.y*i,e.z*i)*r,a=t((e.y+.17)*i,e.z*i,e.x*i)*r,l=t((e.z+.13)*i,e.x*i,e.y*i)*r),o&&(s+=(2*Math.random()-1)*o,a+=(2*Math.random()-1)*o,l+=(2*Math.random()-1)*o),e.newPos.x=e.x+s,e.newPos.y=e.y+a,e.newPos.z=e.z+l,e.newPos.set=!0}},this),Deformer._repositionChangedVertices(e)}static _repositionChangedVertices(e,t){e.voxels.minX,e.voxels.maxX,e.voxels.minY,e.voxels.maxY,e.voxels.minZ,e.voxels.maxZ;t?e.forEachVertex(function(e){e.newPos.set&&(e.x=e.newPos.x,e.y=e.newPos.y,e.z=e.newPos.z,e.newPos.set=!1)},this):e.forEachVertex(function(e){e.newPos.set&&(e.x=e.flatten.x||e.clamp.x?e.x:e.newPos.x,e.y=e.flatten.y||e.clamp.y?e.y:e.newPos.y,e.z=e.flatten.z||e.clamp.z?e.z:e.newPos.z,e.newPos.set=!1)},this)}}class VerticesTransformer{static transformVertices(e){let t=e._determineBounds(),s=new Matrix;s=Matrix.multiply(s,Matrix.translate(e.position.x,e.position.y,e.position.z)),s=Matrix.multiply(s,Matrix.rotate(e.rotation.z,0,0,1)),s=Matrix.multiply(s,Matrix.rotate(e.rotation.y,0,1,0)),s=Matrix.multiply(s,Matrix.rotate(e.rotation.x,1,0,0)),s=Matrix.multiply(s,Matrix.scale(e.scale.x,e.scale.y,e.scale.z)),s=Matrix.multiply(s,Matrix.scale(t.scale.x,t.scale.y,t.scale.z)),s=Matrix.multiply(s,Matrix.translate(t.offset.x,t.offset.y,t.offset.z));let a=Matrix.inverse(s);a=Matrix.transpose(a),e.forEachVertex(function(t){s.transformPoint(t),t.averageNormal&&(a.transformVector(t.averageNormal),e._normalize(t.averageNormal))},this),e.voxels.forEach(function(t){for(let s in t.faces){let r=t.faces[s];if(r&&!r.skipped)for(let t=0;t<r.normals.length;t++)r.normals[t].transformed||(a.transformVector(r.normals[t]),e._normalize(r.normals[t]),r.normals[t].transformed=!0)}},this)}}class NormalsCalculator{static calculateNormals(e){let t=e.tile,s=e.voxels;s.forEach(function(a){for(let r in a.faces){let i=a.faces[r];if(i.skipped)continue;let o={x:(i.vertices[0].x+i.vertices[1].x+i.vertices[2].x+i.vertices[3].x)/4,y:(i.vertices[0].y+i.vertices[1].y+i.vertices[2].y+i.vertices[3].y)/4,z:(i.vertices[0].z+i.vertices[1].z+i.vertices[2].z+i.vertices[3].z)/4};i.normals=[];for(let l=0;l<4;l++){let n=i.vertices[l],m=i.vertices[(l+3)%4];n.normal||(n.normal={x:0,y:0,z:0},n.averageNormal={x:0,y:0,z:0});let h={x:m.x-n.x,y:m.y-n.y,z:m.z-n.z},c={x:o.x-n.x,y:o.y-n.y,z:o.z-n.z};e._normalize(h),e._normalize(c);let u={x:h.y*c.z-h.z*c.y,y:h.z*c.x-h.x*c.z,z:h.x*c.y-h.y*c.x};t&&((t.nx&&"nx"===r||t.px&&"px"===r)&&(n.y<s.minY+.1||n.y>s.maxY+.9||n.z<s.minZ+.1||n.z>s.maxZ+.9)&&(u.y=0,u.z=0),(t.ny&&"ny"===r||t.py&&"py"===r)&&(n.x<s.minX+.1||n.x>s.maxX+.9||n.z<s.minZ+.1||n.z>s.maxZ+.9)&&(u.x=0,u.z=0),(t.nz&&"nz"===r||t.pz&&"pz"===r)&&(n.x<s.minX+.1||n.x>s.maxX+.9||n.y<s.minY+.1||n.y>s.maxY+.9)&&(u.x=0,u.y=0)),e._normalize(u),i.normals[l]=u;let x=h.x*c.x+h.y*c.y+h.z*c.z,p=Math.acos(x);a.material.lighting!==SVOX.SMOOTH&&(a.material.lighting!==SVOX.BOTH||i.flattened||i.clamped||!1===i.equidistant)||(n.normal.x+=p*u.x,n.normal.y+=p*u.y,n.normal.z+=p*u.z),n.averageNormal.x+=p*u.x,n.averageNormal.y+=p*u.y,n.averageNormal.z+=p*u.z}}},this),e.forEachVertex(function(t){e._normalize(t.normal),e._normalize(t.averageNormal)},this),e.voxels.forEach(function(t){for(let s in t.faces){let a=t.faces[s];a.skipped||(t.material.lighting!==SVOX.SMOOTH&&(t.material.lighting!==SVOX.BOTH||a.flattened||a.clamped||!1===a.equidistant)||(a.normals=[e._isZero(a.vertices[0].normal)?a.normals[0]:a.vertices[0].normal,e._isZero(a.vertices[1].normal)?a.normals[1]:a.vertices[1].normal,e._isZero(a.vertices[2].normal)?a.normals[2]:a.vertices[2].normal,e._isZero(a.vertices[3].normal)?a.normals[3]:a.vertices[3].normal]))}},this),e.forEachVertex(function(e){delete e.normal},this)}}class LightsCalculator{static calculateLights(e){let t=e.lights;if(0!==t.length){for(let s=0;s<t.length;s++)t[s].direction&&(t[s].normalizedDirection=e._normalize({x:t[s].direction.x,y:t[s].direction.y,z:t[s].direction.z}));e.voxels.forEach(function(e){if(e.material.lights)for(let s in e.faces){let a=e.faces[s];if(!a.skipped){a.light=[{r:0,g:0,b:0},{r:0,g:0,b:0},{r:0,g:0,b:0},{r:0,g:0,b:0}];for(let e=0;e<4;e++){let s=a.vertices[e],r=a.normals[e];for(let i=0;i<t.length;i++){let o=t[i],l=o.strength,n=o.normalizedDirection,m=0;if(o.position){let e={x:o.position.x-s.x,y:o.position.y-s.y,z:o.position.z-s.z};m=Math.sqrt(e.x*e.x+e.y*e.y+e.z*e.z),n={x:e.x/m,y:e.y/m,z:e.z/m}}n&&(l=o.strength*Math.max(r.x*n.x+r.y*n.y+r.z*n.z,0)),o.position&&o.distance&&(l*=1-Math.min(m/o.distance,1)),a.light[e].r+=o.color.r*l,a.light[e].g+=o.color.g*l,a.light[e].b+=o.color.b*l}}}}},this,!0)}}}class AOCalculator{static calculateAmbientOcclusion(e){if(!(e.ao||e.materials.find(function(e){return e.ao})))return;let t=this._getAllFaceTriangles(e),s=this._trianglesToOctree(t);s=this._aoSidesToOctree(e,s);let a=e.aoSamples,r=this._generateFibonacciSamples(a);e.triCount=0,e.octCount=0;let i={};e.voxels.forEach(function(t){let o=t.material.ao||e.ao;if(!o||0===o.maxDistance||0===o.strength||o.angle<1||0===t.material.opacity)return;let l=o.maxDistance*Math.max(e.scale.x,e.scale.y,e.scale.z),n=o.strength,m=Math.cos(o.angle/180*Math.PI);for(let o in t.faces){let h=t.faces[o];if(!h.skipped){h.ao[0]=0,h.ao[1]=0,h.ao[2]=0,h.ao[3]=0;for(let t=0;t<4;t++){let o=h.vertices[t],c=h.normals[t],u=`${o.x}|${o.y}|${o.z}|${c.x}|${c.y}|${c.z}`,x=i[u];if(x){h.ao[t]=x;continue}let p=h.vertices[(t+2)%4],f={x:.99999*o.x+1e-5*p.x+c.x/1e4,y:.99999*o.y+1e-5*p.y+c.y/1e4,z:.99999*o.z+1e-5*p.z+c.z/1e4},g=0,y=0;for(let t=0;t<a;t++){let a=r[t];if(a.x*c.x+a.y*c.y+a.z*c.z<=m)continue;let i=AOCalculator._distanceToOctree(e,f,a,l,s);g+=i=(i||l)/l,y++}0===y?h.ao[t]=0:(g=Math.max(Math.min(g/y,1),0),h.ao[t]=1-Math.pow(g,n)),i[u]=h.ao[t]}}}},this,!0)}static _getAllFaceTriangles(e){let t=[];return e.voxels.forEach(function(e){if(!(e.material.opacity<.75))for(let s in e.faces){let a=e.faces[s];a.skipped||(t.push([a.vertices[2],a.vertices[1],a.vertices[0]]),t.push([a.vertices[0],a.vertices[3],a.vertices[2]]))}},this,!0),t}static _trianglesToOctree(e){let t=e.length;if(t<=32){let s={minx:Number.MAX_VALUE,miny:Number.MAX_VALUE,minz:Number.MAX_VALUE,maxx:-Number.MAX_VALUE,maxy:-Number.MAX_VALUE,maxz:-Number.MAX_VALUE,triangles:e};for(let a=0;a<t;a++){let t=e[a];s.minx=Math.min(s.minx,t[0].x,t[1].x,t[2].x),s.miny=Math.min(s.miny,t[0].y,t[1].y,t[2].y),s.minz=Math.min(s.minz,t[0].z,t[1].z,t[2].z),s.maxx=Math.max(s.maxx,t[0].x,t[1].x,t[2].x),s.maxy=Math.max(s.maxy,t[0].y,t[1].y,t[2].y),s.maxz=Math.max(s.maxz,t[0].z,t[1].z,t[2].z)}return s}{let s=0,a=0,r=0;for(let i=0;i<t;i++){let t=e[i];s+=t[0].x+t[1].x+t[2].x,a+=t[0].y+t[1].y+t[2].y,r+=t[0].z+t[1].z+t[2].z}s/=t,a/=t,r/=t;let i=[];for(let o=0;o<t;o++){let t=e[o],l=(t[0].x+t[1].x+t[2].x<s?0:1)+2*(t[0].y+t[1].y+t[2].y<a?0:1)+4*(t[0].z+t[1].z+t[2].z<r?0:1);i[l]?i[l].push(t):i[l]=[t]}let o={minx:Number.MAX_VALUE,miny:Number.MAX_VALUE,minz:Number.MAX_VALUE,maxx:-Number.MAX_VALUE,maxy:-Number.MAX_VALUE,maxz:-Number.MAX_VALUE,partitions:i};for(let e=7;e>=0;e--)i[e]?(i[e]=AOCalculator._trianglesToOctree(i[e]),o.minx=Math.min(o.minx,i[e].minx),o.miny=Math.min(o.miny,i[e].miny),o.minz=Math.min(o.minz,i[e].minz),o.maxx=Math.max(o.maxx,i[e].maxx),o.maxy=Math.max(o.maxy,i[e].maxy),o.maxz=Math.max(o.maxz,i[e].maxz)):i.splice(e,1);return o}}static _distanceToOctree(e,t,s,a,r,i){if(e.octCount++,i||(i={x:t.x+s.x*a,y:t.y+s.y*a,z:t.z+s.z*a}),!AOCalculator._hitsBox(t,i,r))return null;if(r.triangles){let i=AOCalculator._distanceToModel(e,t,s,a,r.triangles);return i||e.octMissCount++,i}let o=a;for(let l=0;l<r.partitions.length;l++){let n=AOCalculator._distanceToOctree(e,t,s,a,r.partitions[l],i);n&&(o=Math.min(o,n))}return o}static _aoSidesToOctree(e,t){let s=e._determineBounds().bounds,a=[];if(e._aoSides.nx&&a.push([{x:s.minX-.05,y:1e6,z:-1e6},{x:s.minX-.05,y:1e6,z:1e6},{x:s.minX-.05,y:-1e7,z:0}]),e._aoSides.px&&a.push([{x:s.maxX+.05,y:1e6,z:1e6},{x:s.maxX+.05,y:1e6,z:-1e6},{x:s.maxX+.05,y:-1e7,z:0}]),e._aoSides.ny&&a.push([{x:1e6,y:s.minY-.05,z:-1e6},{x:-1e6,y:s.minY-.05,z:-1e6},{x:0,y:s.minY-.05,z:1e7}]),e._aoSides.py&&a.push([{x:-1e6,y:s.maxY+.05,z:-1e6},{x:1e6,y:s.maxY+.05,z:-1e6},{x:0,y:s.maxY+.05,z:1e7}]),e._aoSides.nz&&a.push([{x:1e6,y:1e6,z:s.minZ-.05},{x:-1e6,y:1e6,z:s.minZ-.05},{x:0,y:-1e7,z:s.minZ-.05}]),e._aoSides.pz&&a.push([{x:-1e6,y:1e6,z:s.maxZ+.05},{x:1e6,y:1e6,z:s.maxZ+.05},{x:0,y:-1e7,z:s.maxZ+.05}]),a.length>0){let e=AOCalculator._trianglesToOctree(a);t={minx:-Number.MAX_VALUE,miny:-Number.MAX_VALUE,minz:-Number.MAX_VALUE,maxx:Number.MAX_VALUE,maxy:Number.MAX_VALUE,maxz:Number.MAX_VALUE,partitions:[t,e]}}return t}static _hitsBox(e,t,s){if(e.x<s.minx&&t.x<s.minx)return!1;if(e.x>s.maxx&&t.x>s.maxx)return!1;if(e.y<s.miny&&t.y<s.miny)return!1;if(e.y>s.maxy&&t.y>s.maxy)return!1;if(e.z<s.minz&&t.z<s.minz)return!1;if(e.z>s.maxz&&t.z>s.maxz)return!1;if(e.x>=s.minx&&e.x<=s.maxx&&e.y>=s.miny&&e.y<=s.maxy&&e.z>=s.minz&&e.z<=s.maxz)return!0;if(e.x<t.x){let a=(s.minx-e.x)/(t.x-e.x),r=e.y+a*(t.y-e.y),i=e.z+a*(t.z-e.z);if(r>=s.miny&&r<=s.maxy&&i>=s.minz&&i<=s.maxz)return!0}if(e.x>t.x){let a=(s.maxx-e.x)/(t.x-e.x),r=e.y+a*(t.y-e.y),i=e.z+a*(t.z-e.z);if(r>=s.miny&&r<=s.maxy&&i>=s.minz&&i<=s.maxz)return!0}if(e.y<t.y){let a=(s.miny-e.y)/(t.y-e.y),r=e.x+a*(t.x-e.x),i=e.z+a*(t.z-e.z);if(r>=s.minx&&r<=s.maxx&&i>=s.minz&&i<=s.maxz)return!0}if(e.y>t.y){let a=(s.maxy-e.y)/(t.y-e.y),r=e.x+a*(t.x-e.x),i=e.z+a*(t.z-e.z);if(r>=s.minx&&r<=s.maxx&&i>=s.minz&&i<=s.maxz)return!0}if(e.z<t.z){let a=(s.minz-e.z)/(t.z-e.z),r=e.x+a*(t.x-e.x),i=e.y+a*(t.y-e.y);if(r>=s.minx&&r<=s.maxx&&i>=s.miny&&i<=s.maxy)return!0}if(e.z>t.z){let a=(s.maxz-e.z)/(t.z-e.z),r=e.x+a*(t.x-e.x),i=e.y+a*(t.y-e.y);if(r>=s.minx&&r<=s.maxx&&i>=s.miny&&i<=s.maxy)return!0}return!1}static _distanceToModel(e,t,s,a,r){let i=null;for(let o=0;o<r.length;o++){let l=r[o],n=this._triangleDistance(e,t,s,l[0],l[1],l[2]);n&&(i?i=Math.min(i,n):n<a&&(i=n))}return i}static _triangleDistance(e,t,s,a,r,i){e.triCount++;let o=r.x-a.x,l=r.y-a.y,n=r.z-a.z,m=i.x-a.x,h=i.y-a.y,c=i.z-a.z,u=s.y*c-s.z*h,x=s.z*m-s.x*c,p=s.x*h-s.y*m,f=o*u+l*x+n*p;if(f<Number.EPSILON)return null;let g=1/f,y=t.x-a.x,d=t.y-a.y,v=t.z-a.z,z=g*(y*u+d*x+v*p);if(z<0||z>1)return null;let _=d*n-v*l,M=v*o-y*n,S=y*l-d*o,b=g*(s.x*_+s.y*M+s.z*S);if(b<0||z+b>1)return null;let E=g*(m*_+h*M+c*S);return E<=Number.EPSILON?null:E}static _generateFibonacciSamples(e){let t=[],s=(2-(Math.sqrt(5)+1)/2)*(2*Math.PI);for(let a=1;a<=e;++a){let r=Math.asin(2*a/(e+1)-1),i=s*a,o=Math.cos(i)*Math.cos(r),l=Math.sin(r),n=Math.sin(i)*Math.cos(r);t.push({x:o,y:l,z:n})}return t}static _generateOctahedronSamples(e){let t=[],s=Math.PI/2/e;for(let a=0;a<=e;a++){let r=a*s,i=Math.cos(r),o=Math.sin(r),l=Math.max(1,4*a),n=2*Math.PI/l;for(let s=0;s<l;s++){let r=s*n,l=o*Math.sin(r),m=o*Math.cos(r);t.push({x:l,y:i,z:m}),a<e&&t.push({x:l,y:-i,z:m})}l+=4}return t}}class ColorCombiner{static combineColors(e){let t=!!e.materials.find(e=>e.colors.length>1&&e.fade);e.voxels.forEach(function(s){let a=t&&s.material.fade&&s.material.colors.length>1;for(let t in s.faces){let r=s.faces[t];r&&!r.skipped&&(a?this._fadeFaceColor(s,r):delete r.vertexColors,this._combineFaceColors(e,s,r))}},this)}static _fadeFaceColor(e,t){t.vertexColors=[null,null,null,null];for(let s=0;s<4;s++){let a=t.vertices[s],r=0,i=0,o=0,l=0;for(let t=0;t<a.colors.length;t++){let s=a.colors[t];s.material===e.material&&(r+=s.r,i+=s.g,o+=s.b,l++)}t.vertexColors[s]=Color.fromRgb(r/l,i/l,o/l)}}static _combineFaceColors(e,t,s){if(1!==t.material.colorCount||t.material.ao||e.ao||0!==e.lights.length)if(t.material.colorCount>1&&!t.material.ao&&!e.ao&&0===e.lights.length&&!s.vertexColors)s.color=t.color;else{s.vertexColors=s.vertexColors||[t.color.clone(),t.color.clone(),t.color.clone(),t.color.clone()];let a=s.vertexColors,r=s.light||[{r:1,g:1,b:1},{r:1,g:1,b:1},{r:1,g:1,b:1},{r:1,g:1,b:1}],i=s.ao;for(let s=0;s<4;s++){let o=a[s],l=r[s],n=1-i[s],m=t.material.ao?t.material.ao.color:e.ao?e.ao.color:o;o.r=l.r*n*o.r+m.r*(1-n),o.g=l.g*n*o.g+m.g*(1-n),o.b=l.b*n*o.b+m.b*(1-n)}}else;}}class UVAssigner{static assignUVs(e){e.voxels.forEach(function(t){let s=t.material,a=0,r=1,i=1;(s.map||s.normalMap||s.roughnessMap||s.metalnessMap||s.emissiveMap)&&(-1===s.mapTransform.uscale&&(r=1/Math.max(e.voxels.size.x,e.voxels.size.y,e.voxels.size.z)),-1===s.mapTransform.vscale&&(i=1/Math.max(e.voxels.size.x,e.voxels.size.y,e.voxels.size.z)),(s.map&&s.map.cube||s.normalMap&&s.normalMap.cube||s.roughnessMap&&s.roughnessMap.cube||s.metalnessMap&&s.metalnessMap.cube||s.emissiveMap&&s.emissiveMap.cube)&&(a=1,r/=4,i/=2));for(let e in t.faces){let s=t.faces[e];if(s.skipped)continue;let o=SVOX._FACEUVS[e];s.uv=[],s.uv[o.order[0]]={u:a*o.uo+(t[o.u]+1e-4)*o.ud*r,v:a*o.vo+(t[o.v]+1e-4)*o.vd*i},s.uv[o.order[1]]={u:a*o.uo+(t[o.u]+1e-4)*o.ud*r,v:a*o.vo+(t[o.v]+.9999)*o.vd*i},s.uv[o.order[2]]={u:a*o.uo+(t[o.u]+.9999)*o.ud*r,v:a*o.vo+(t[o.v]+.9999)*o.vd*i},s.uv[o.order[3]]={u:a*o.uo+(t[o.u]+.9999)*o.ud*r,v:a*o.vo+(t[o.v]+1e-4)*o.vd*i}}},this,!1)}}class Simplifier{static simplify(e){let t={},s={},a={},r={},i=function(){t.lastVoxel=null,s.lastVoxel=null,a.lastVoxel=null,r.lastVoxel=null};for(let o=e.voxels.minX;o<=e.voxels.maxX;o++)for(let l=e.voxels.minZ;l<=e.voxels.maxZ;l++)for(let n=e.voxels.minY;n<=e.voxels.maxY;n++){let m=e.voxels.getVoxel(o,n,l);m?(Simplifier._mergeFaces(t,m,"x","z","y","nx",0,1,2,3),Simplifier._mergeFaces(s,m,"x","z","y","px",0,1,2,3),Simplifier._mergeFaces(a,m,"x","z","y","nz",0,1,2,3),Simplifier._mergeFaces(r,m,"x","z","y","pz",0,1,2,3)):i()}i();for(let o=e.voxels.minX;o<=e.voxels.maxX;o++)for(let l=e.voxels.minY;l<=e.voxels.maxY;l++)for(let n=e.voxels.minZ;n<=e.voxels.maxZ;n++){let m=e.voxels.getVoxel(o,l,n);m?(Simplifier._mergeFaces(t,m,"x","y","z","nx",1,2,3,0),Simplifier._mergeFaces(s,m,"x","y","z","px",3,0,1,2),Simplifier._mergeFaces(a,m,"x","y","z","ny",0,1,2,3),Simplifier._mergeFaces(r,m,"x","y","z","py",2,3,0,1)):i()}i();for(let o=e.voxels.minY;o<=e.voxels.maxY;o++)for(let l=e.voxels.minZ;l<=e.voxels.maxZ;l++)for(let n=e.voxels.minX;n<=e.voxels.maxX;n++){let m=e.voxels.getVoxel(n,o,l);m?(Simplifier._mergeFaces(t,m,"y","z","x","ny",1,2,3,0),Simplifier._mergeFaces(s,m,"y","z","x","py",1,2,3,0),Simplifier._mergeFaces(a,m,"y","z","x","nz",3,0,1,2),Simplifier._mergeFaces(r,m,"y","z","x","pz",1,2,3,0)):i()}}static _mergeFaces(e,t,s,a,r,i,o,l,n,m){let h=null;if(t&&(h=t.faces[i]),t&&e.lastVoxel&&h&&!h.skipped&&e.lastFace&&t.color===e.lastVoxel.color&&t[s]===e.lastVoxel[s]&&t[a]===e.lastVoxel[a]){let c=h.normals,u=e.lastFace.normals,x=h.vertexColors,p=e.lastFace.vertexColors,f=h.vertices,g=e.lastFace.vertices,y=h.ao,d=e.lastFace.ao,v=Math.sqrt((f[l].x-f[o].x)*(f[l].x-f[o].x)+(f[l].y-f[o].y)*(f[l].y-f[o].y)+(f[l].z-f[o].z)*(f[l].z-f[o].z))/Math.sqrt((f[l].x-g[o].x)*(f[l].x-g[o].x)+(f[l].y-g[o].y)*(f[l].y-g[o].y)+(f[l].z-g[o].z)*(f[l].z-g[o].z));if(Simplifier._normalEquals(c[0],u[0])&&Simplifier._normalEquals(c[1],u[1])&&Simplifier._normalEquals(c[2],u[2])&&Simplifier._normalEquals(c[3],u[3])&&(!x&&!p||Simplifier._colorEquals(x[0],p[0])&&Simplifier._colorEquals(x[1],p[1])&&Simplifier._colorEquals(x[2],p[2])&&Simplifier._colorEquals(x[3],p[3]))&&y[0]===d[0]&&y[1]===d[1]&&y[2]===d[2]&&y[3]===d[3]&&Math.abs(g[l][s]-(1-v)*f[l][s]-v*g[o][s])<=10*Number.EPSILON&&Math.abs(g[l][a]-(1-v)*f[l][a]-v*g[o][a])<=10*Number.EPSILON&&Math.abs(g[l][r]-(1-v)*f[l][r]-v*g[o][r])<=10*Number.EPSILON&&Math.abs(g[n][s]-(1-v)*f[n][s]-v*g[m][s])<=10*Number.EPSILON&&Math.abs(g[n][a]-(1-v)*f[n][a]-v*g[m][a])<=10*Number.EPSILON&&Math.abs(g[n][r]-(1-v)*f[n][r]-v*g[m][r])<=10*Number.EPSILON)return g[l]=f[l],g[n]=f[n],e.lastFace.uv[l]=h.uv[l],e.lastFace.uv[n]=h.uv[n],void delete t.faces[i]}e.lastVoxel=t,e.lastFace=h}static _normalEquals(e,t){return Math.abs(e.x-t.x)<.01&&Math.abs(e.y-t.y)<.01&&Math.abs(e.z-t.z)<.01}static _colorEquals(e,t){return e.r===t.r&&e.g===t.g&&e.b===t.b}static _faceVerticesToString(e){return"["+`${Simplifier._vertexToString(e[0],0)},`+`${Simplifier._vertexToString(e[1],0)},`+`${Simplifier._vertexToString(e[2],0)},`+`${Simplifier._vertexToString(e[3],0)}`+"]"}static _vertexToString(e,t){return`{${e.x.toFixed(t)},${e.y.toFixed(t)},${e.z.toFixed(t)}}`}}class FaceAligner{static alignFaceDiagonals(e){e.forEachVertex(function(e){e.count=0},this);let t=.1*Math.min(e.scale.x,e.scale.y,e.scale.z);t*=t,e.voxels.forEach(function(e){for(let s in e.faces){let a=e.faces[s];if(a.skipped)continue;a.vertices[0].count++,a.vertices[1].count++,a.vertices[2].count++,a.vertices[3].count++;let r=(a.vertices[0].x+a.vertices[2].x)/2,i=(a.vertices[0].y+a.vertices[2].y)/2,o=(a.vertices[0].z+a.vertices[2].z)/2,l=(a.vertices[1].x-r)*(a.vertices[1].x-r)+(a.vertices[1].y-i)*(a.vertices[1].y-i)+(a.vertices[1].z-o)*(a.vertices[1].z-o),n=(a.vertices[3].x-r)*(a.vertices[3].x-r)+(a.vertices[3].y-i)*(a.vertices[3].y-i)+(a.vertices[3].z-o)*(a.vertices[3].z-o),m=(a.vertices[1].x+a.vertices[3].x)/2,h=(a.vertices[1].y+a.vertices[3].y)/2,c=(a.vertices[1].z+a.vertices[3].z)/2,u=(a.vertices[0].x-m)*(a.vertices[0].x-m)+(a.vertices[0].y-h)*(a.vertices[0].y-h)+(a.vertices[0].z-c)*(a.vertices[0].z-c),x=(a.vertices[2].x-m)*(a.vertices[2].x-m)+(a.vertices[2].y-h)*(a.vertices[2].y-h)+(a.vertices[2].z-c)*(a.vertices[2].z-c);if(l<t||n<t)a.vertices.push(a.vertices.shift()),a.normals.push(a.normals.shift()),a.ao.push(a.ao.shift()),a.uv.push(a.uv.shift()),a.vertexColors&&a.vertexColors.push(a.vertexColors.shift());else if(u<t||x<t);else if(a.ao&&Math.min(a.ao[0],a.ao[1],a.ao[2],a.ao[3])!==Math.max(a.ao[0],a.ao[1],a.ao[2],a.ao[3])){Math.abs(a.ao[0]-a.ao[2])<Math.abs(a.ao[1]-a.ao[3])&&(a.vertices.push(a.vertices.shift()),a.normals.push(a.normals.shift()),a.ao.push(a.ao.shift()),a.uv.push(a.uv.shift()),a.vertexColors&&a.vertexColors.push(a.vertexColors.shift()))}else{let e=FaceAligner._getVertexSum(a.vertices[0]);for(;FaceAligner._getVertexSum(a.vertices[1])<e||FaceAligner._getVertexSum(a.vertices[2])<e||FaceAligner._getVertexSum(a.vertices[3])<e;)a.vertices.push(a.vertices.shift()),a.normals.push(a.normals.shift()),a.ao.push(a.ao.shift()),a.uv.push(a.uv.shift()),a.vertexColors&&a.vertexColors.push(a.vertexColors.shift()),e=FaceAligner._getVertexSum(a.vertices[0])}}},this)}static _getVertexSum(e){return Math.abs(e.x)+Math.abs(e.y)+Math.abs(e.z)}}class Light{constructor(e,t,s,a,r,i,o){this.color=e,this.strength=t,this.direction=s,this.position=a,this.distance=r,this.size=i,this.detail=o}}class Model{set origin(e){this._origin=Planar.parse(e)}get origin(){return Planar.toString(this._origin)}set flatten(e){this._flatten=Planar.parse(e)}get flatten(){return Planar.toString(this._flatten)}set clamp(e){this._clamp=Planar.parse(e)}get clamp(){return Planar.toString(this._clamp)}set skip(e){this._skip=Planar.parse(e)}get skip(){return Planar.toString(this._skip)}set tile(e){this._tile=Planar.parse(e),this._tile.x&&(this._tile=Planar.combine(this._tile,{nx:!0,px:!0})),this._tile.y&&(this._tile=Planar.combine(this._tile,{ny:!0,py:!0})),this._tile.z&&(this._tile=Planar.combine(this._tile,{nz:!0,pz:!0})),this._tile.x=!1,this._tile.y=!1,this._tile.z=!1}get tile(){return Planar.toString(this._tile)}set shape(e){if(this._shape=(e||"box").trim(),!["box","sphere","cylinder-x","cylinder-y","cylinder-z"].includes(this._shape))throw{name:"SyntaxError",message:`Unrecognized shape ${this._shape}. Allowed are box, sphere, cylinder-x, cylinder-y and cylinder-z`}}get shape(){return this._shape}setAo(e){this._ao=e}get ao(){return this._ao}set aoSides(e){this._aoSides=Planar.parse(e)}get aoSides(){return Planar.toString(this._aoSides)}set aoSamples(e){this._aoSamples=Math.round(e)}get aoSamples(){return this._aoSamples}constructor(){this.name="main",this.lights=[],this.textures={},this.materials=new MaterialList,this.voxels=new VoxelMatrix,this.vertices=[],this.scale={x:1,y:1,z:1},this.rotation={x:0,y:0,z:0},this.position={x:0,y:0,z:0},this.autoResize=!1,this._origin=Planar.parse("x y z"),this._flatten=Planar.parse(""),this._clamp=Planar.parse(""),this._skip=Planar.parse(""),this._tile=Planar.parse(""),this._ao=void 0,this._aoSamples=50,this._aoSides=Planar.parse(""),this.shape="box",this.wireframe=!1,this.triCount=0,this.octCount=0,this.octMissCount=0}_setVertex(e,t,s,a){a.x=e,a.y=t,a.z=s;let r=this.vertices[s+1e6];r||(r=[],this.vertices[s+1e6]=r);let i=r[t+1e6];i||(i=[],r[t+1e6]=i),i[e+1e6]=a}_getVertex(e,t,s){let a=this.vertices[s+1e6];return a&&(a=a[t+1e6])?a[e+1e6]:null}forEachVertex(e,t){for(let s in this.vertices){let a=this.vertices[s];for(let s in a){let r=a[s];for(let s in r)e.apply(t,[r[s]])}}}prepareForWrite(){this.materials.forEach(function(e){e.bounds.reset(),e.colors.forEach(function(e){e.count=0},this)},this),this.shell&&this.shell.forEach(function(e){e.color.count++},this),this.materials.forEach(function(e){e.shell&&e.shell.forEach(function(e){e.color.count++},this)},this),this.lights.some(e=>e.size)&&(this.materials.materials[0].colors[0].count=1),this.voxels.prepareForWrite()}prepareForRender(){this.prepareForWrite();let e=Deformer.maximumDeformCount(this);this.vertices=[],this.voxels.forEach(function(t){let s=0;for(let a=0;a<SVOX._FACES.length;a++){let r=SVOX._FACES[a],i=SVOX._NEIGHBORS[r],o=this._createFace(t,r,this.voxels.getVoxel(t.x+i.x,t.y+i.y,t.z+i.z),e>0);o&&(t.faces[r]=o,o.skipped||t.color.count++,s++)}t.visible=s>0},this,!1),this._fixClampedLinks(),Deformer.changeShape(this,this._shape),Deformer.deform(this,e),Deformer.warpAndScatter(this),NormalsCalculator.calculateNormals(this),VerticesTransformer.transformVertices(this),LightsCalculator.calculateLights(this),AOCalculator.calculateAmbientOcclusion(this),ColorCombiner.combineColors(this),UVAssigner.assignUVs(this),Simplifier.simplify(this),FaceAligner.alignFaceDiagonals(this)}_logLinks(){this.voxels.forEach(function(e){for(let t in e.faces){let s=e.faces[t];if(s.skipped)continue;let a=`VOXEL (${e.x},${e.y},${e.z}):${t}\r\n`;for(let e=0;e<4;e++){let t=s.vertices[e];t.fullyClamped=t.fullyClamped||t.nrOfClampedLinks===t.links.length,a+=`    VERTEX (${t.x},${t.y},${t.z}):${t.fullyClampes?"fully":""} :`;for(let e=0;e<t.links.length;e++){let s=t.links[e];a+=`(${s.x},${s.y},${s.z}) `}a+="\r\n"}console.log(a)}},this)}_fixClampedLinks(){this.voxels.forEach(function(e){for(let t in e.faces){let s=e.faces[t];if(s.clamped)for(let e=0;e<4;e++){let t=s.vertices[e];t.fullyClamped=t.fullyClamped||t.nrOfClampedLinks===t.links.length,t.fullyClamped&&(t.links=[])}}}),this.voxels.forEach(function(e){for(let t in e.faces){let s=e.faces[t];if(s.clamped)for(let e=0;e<4;e++){let t=s.vertices[e],a=s.vertices[(e+1)%4];t.fullyClamped&&-1===t.links.indexOf(a)&&t.links.push(a),a.fullyClamped&&-1===a.links.indexOf(t)&&a.links.push(t)}}})}_determineBounds(){let e=Number.POSITIVE_INFINITY,t=Number.POSITIVE_INFINITY,s=Number.POSITIVE_INFINITY,a=Number.NEGATIVE_INFINITY,r=Number.NEGATIVE_INFINITY,i=Number.NEGATIVE_INFINITY;this.voxels.forEach(function(o){for(let l in o.faces){let n=o.faces[l];if(!n.skipped)for(let o=0;o<4;o++){let l=n.vertices[o];l.x<e&&(e=l.x),l.y<t&&(t=l.y),l.z<s&&(s=l.z),l.x>a&&(a=l.x),l.y>r&&(r=l.y),l.z>i&&(i=l.z)}}});let o=-(e+a)/2,l=-(t+r)/2,n=-(s+i)/2;this._origin.nx&&(o=-e),this._origin.px&&(o=-a),this._origin.ny&&(l=-t),this._origin.py&&(l=-r),this._origin.nz&&(n=-s),this._origin.pz&&(n=-i);let m=(this.voxels.maxX-this.voxels.minX+1)/(a-e),h=(this.voxels.maxY-this.voxels.minY+1)/(r-t),c=(this.voxels.maxZ-this.voxels.minZ+1)/(i-s);return m=h=c=this.autoResize?Math.min(m,h,c):1,{bounds:{minX:e,minY:t,minZ:s,maxX:a,maxY:r,maxZ:i},offset:{x:o,y:l,z:n},scale:{x:m,y:h,z:c}}}_lookAtVertices(e,t,s,a,r,i,o,l,n){let m=Matrix.lookAt(e,t,s,a,r,i,o,l,n);this.forEachVertex(function(e){m.transformPoint(e)},this);let h=Matrix.inverse(m);h=Matrix.transpose(h),this.voxels.forEach(function(e){for(let t in e.faces){let s=e.faces[t];for(let e=0;e<s.normals.length;e++)s.normals[e].transformed||(h.transformVector(s.normals[e]),s.normals[e].transformed=!0)}},this)}_createFace(e,t,s,a){if(!e||!e.material||0===e.material.opacity)return null;if(s&&s.material){if(!s.material.isTransparent&&!s.material.wireframe)return null;if(e.material.isTransparent||e.material.wireframe){if(!e.material.isTransparent||e.material.wireframe||!s.material.wireframe)return null}else;}else;let r=this._isFacePlanar(e,t,e.material._flatten,this._flatten),i=this._isFacePlanar(e,t,e.material._clamp,this._clamp),o=this._isFacePlanar(e,t,e.material._skip,this._skip),l={vertices:[this._createVertex(e,t,0,r,i),this._createVertex(e,t,1,r,i),this._createVertex(e,t,2,r,i),this._createVertex(e,t,3,r,i)],ao:[0,0,0,0],uv:[null,null,null,null],flattened:r,clamped:i,skipped:o};return a&&this._linkVertices(e,l,t),l}_createVertex(e,t,s,a,r){let i=SVOX._VERTICES[t][s],o=e.x+i.x,l=e.y+i.y,n=e.z+i.z,m=e.material,h={x:!1,y:!1,z:!1},c={x:!1,y:!1,z:!1};h[t[1]]=a,c[t[1]]=r;let u=this._getVertex(o,l,n);return u?(u.colors.push(e.color),u.flatten.x=u.flatten.x||h.x,u.flatten.y=u.flatten.y||h.y,u.flatten.z=u.flatten.z||h.z,u.clamp.x=u.clamp.x||c.x,u.clamp.y=u.clamp.y||c.y,u.clamp.z=u.clamp.z||c.z,m.deform?u.deform&&this._getDeformIntegral(m.deform)<this._getDeformIntegral(u.deform)&&(u.deform=m.deform):u.deform=null,m.warp?u.warp&&(m.warp.amplitude<u.warp.amplitude||m.warp.amplitude===u.warp.amplitude&&m.warp.frequency>u.warp.frequency)&&(u.warp=m.warp):u.warp=null,m.scatter?u.scatter&&Math.abs(m.scatter)<Math.abs(u.scatter)&&(u.scatter=m.scatter):u.scatter=null):(u={x:o,y:l,z:n,links:[],nrOfClampedLinks:0,colors:[e.color],newPos:{x:0,y:0,z:0,set:!1},deform:m.deform,warp:m.warp,scatter:m.scatter,flatten:h,clamp:c,count:1},this._setVertex(o,l,n,u)),u}_getDeformIntegral(e){return 1===e.damping?e.strength*(e.count+1):e.strength*(1-Math.pow(e.damping,e.count+1))/(1-e.damping)}_isFacePlanar(e,t,s,a){let r=e.material;switch(t){case"nx":return s.x||a.x||s.nx&&e.x===r.bounds.minX||a.nx&&e.x===this.voxels.minX;case"px":return s.x||a.x||s.px&&e.x===r.bounds.maxX||a.px&&e.x===this.voxels.maxX;case"ny":return s.y||a.y||s.ny&&e.y===r.bounds.minY||a.ny&&e.y===this.voxels.minY;case"py":return s.y||a.y||s.py&&e.y===r.bounds.maxY||a.py&&e.y===this.voxels.maxY;case"nz":return s.z||a.z||s.nz&&e.z===r.bounds.minZ||a.nz&&e.z===this.voxels.minZ;case"pz":return s.z||a.z||s.pz&&e.z===r.bounds.maxZ||a.pz&&e.z===this.voxels.maxZ;default:return!1}}_linkVertices(e,t,s){if(t.clamped)for(let e=0;e<4;e++){let s=t.vertices[e];-1===s.links.indexOf(s)&&(s.links.push(s),s.nrOfClampedLinks++)}else for(let e=0;e<4;e++){let s=t.vertices[e],a=t.vertices[(e+1)%4];-1===s.links.indexOf(a)&&s.links.push(a),-1===a.links.indexOf(s)&&a.links.push(s)}}_normalize(e){if(e){let t=Math.sqrt(e.x*e.x+e.y*e.y+e.z*e.z);t>0&&(e.x/=t,e.y/=t,e.z/=t)}return e}_isZero(e){return!e||0===e.x&&0===e.y&&0===e.z}}class ModelReader{static readFromString(e){let t=this._parse(e);return this._validateModel(t),this._createModel(t)}static _parse(e){const t={linecontinuation:new RegExp(/_\s*[\r\n]/gm),modelparts:new RegExp(/\s*(\/\/(.*?)\r?\n)/.source+"|"+/\s*(texture|light|model|material|voxels)\s+/.source+"|"+/\s*([^=,\r\n]+=\s*data:image.*?base64,.*$)\s*/.source+"|"+/\s*([^=,\r\n]+=[^\r\n=;,\/]+)\s*/.source+"|"+/\s*([A-Za-z \(\)\d -]+)\s*/.source,"gm")};let s={lights:[],textures:[],materials:[]},a=s,r=null;return Array.from(e.replaceAll(t.linecontinuation," ").matchAll(t.modelparts),e=>e[0].trim()).filter(e=>e).forEach(function(e){if(e.startsWith("//"));else if("texture"===e)a={id:"<no-name>",cube:!1},s.textures.push(a);else if("light"===e)a={color:"#FFF"},s.lights.push(a);else if("model"===e)a=s;else if("material"===e)a={},s.materials.push(a);else if("voxels"===e)a=s,r="";else if(null!==r)r+=e.replace(/\s/g,"");else{let t=e.indexOf("=");if(-1===t)throw{name:"SyntaxError",message:`Invalid definition '${e}'.`};let s=e.substring(0,t).trim().toLowerCase(),r=e.substring(t+1).trim();a[s]=r}},this),s.voxels=r,s}static _createModel(e){let t=new Model;if(t.size=this._parseXYZInt("size",e.size,null,!0),t.scale=this._parseXYZFloat("scale",e.scale,"1",!0),t.rotation=this._parseXYZFloat("rotation",e.rotation,"0 0 0",!1),t.position=this._parseXYZFloat("position",e.position,"0 0 0",!1),t.autoResize="true"===e.autoresize||!1,t.shape=e.shape,t.wireframe="true"===e.wireframe||!1,t.origin=e.origin,t.flatten=e.flatten,t.clamp=e.clamp,t.skip=e.skip,t.tile=e.tile,t.setAo(this._parseAo(e.ao)),t.aoSides=e.aosides,t.aoSamples=parseInt(e.aosamples||50,10),t.shell=this._parseShell(e.shell),e.lights.some(e=>e.size)){t.materials.createMaterial(SVOX.MATBASIC,SVOX.FLAT,1,0,!1,1,0,!1,!1,SVOX.FRONT,"#FFF",0,!1,null,null,null,null,null,null,-1,-1,0,0,0,0).addColorHEX("#FFFFFF")}return e.lights.forEach(function(e){this._createLight(t,e)},this),e.textures.forEach(function(e){this._createTexture(t,e)},this),e.materials.forEach(function(e){this._createMaterial(t,e)},this),t.colors={},t.materials.forEach(function(e){e.colors.forEach(function(e){t.colors[e.id]=e})}),this._resolveShellColors(t.shell,t),t.materials.forEach(function(e){this._resolveShellColors(e.shell,t)},this),this._createVoxels(t,e.voxels),t}static _createLight(e,t){t.color||(t.color="#FFF 1"),t.color.startsWith("#")||(t.color="#FFF "+t.color),t.strength=parseFloat(t.color.split(" ")[1]||1),t.color=Color.fromHex(t.color.split(" ")[0]),t.direction=this._parseXYZFloat("direction",t.direction,null,!1),t.position=this._parseXYZFloat("position",t.position,null,!1),t.distance=parseFloat(t.distance||0),t.size=Math.max(0,parseFloat(t.size||0)),t.detail=Math.min(3,Math.max(0,parseInt(t.detail||1,10)));let s=new Light(t.color,t.strength,t.direction,t.position,t.distance,t.size,t.detail);e.lights.push(s)}static _createTexture(e,t){t.cube="true"===t.cube||!1,e.textures[t.id]=t}static _createMaterial(e,t){let s=SVOX.FLAT;t.lighting===SVOX.SMOOTH&&(s=SVOX.SMOOTH),t.lighting===SVOX.BOTH&&(s=SVOX.BOTH),t.emissive||(t.emissivemap?t.emissive="#FFF 1":t.emissive="#000 0"),t.emissive.startsWith("#")||(t.emissive="#FFF "+t.emissive),t.emissiveColor=t.emissive.split(" ")[0],t.emissiveIntensity=t.emissive.split(" ")[1]||1,t.ao&&!t.ao.startsWith("#")&&(t.ao="#000 "+t.ao),t.maptransform=t.maptransform||"";let a=e.materials.createMaterial(t.type||SVOX.MATSTANDARD,s,parseFloat(t.roughness||(t.roughnessmap,1)),parseFloat(t.metalness||(t.metalnessmap?1:0)),"true"===t.fade||!1,parseFloat(t.opacity||1),parseFloat(t.alphatest||0),"true"===t.transparent||!1,"true"===t.wireframe||!1,t.side,t.emissiveColor,t.emissiveIntensity,"false"!==t.fog,t.map?e.textures[t.map]:null,t.normalmap?e.textures[t.normalmap]:null,t.roughnessmap?e.textures[t.roughnessmap]:null,t.metalnessmap?e.textures[t.metalnessmap]:null,t.emissivemap?e.textures[t.emissivemap]:null,t.matcap?e.textures[t.matcap]:null,parseFloat(t.maptransform.split(" ")[0]||-1),parseFloat(t.maptransform.split(" ")[1]||-1),parseFloat(t.maptransform.split(" ")[2]||0),parseFloat(t.maptransform.split(" ")[3]||0),parseFloat(t.maptransform.split(" ")[4]||0));t.deform&&a.setDeform(parseFloat(t.deform.split(" ")[0]),parseFloat(t.deform.split(" ")[1]||1),parseFloat(t.deform.split(" ")[2]||1)),t.warp&&a.setWarp(parseFloat(t.warp.split(" ")[0]),parseFloat(t.warp.split(" ")[1]||1)),t.scatter&&(a.scatter=parseFloat(t.scatter)),a.flatten=t.flatten,a.clamp=t.clamp,a.skip=t.skip,a.setAo(this._parseAo(t.ao)),a.shell=this._parseShell(t.shell),a.lights="false"!==t.lights;t.colors=t.colors.replace(/\s*\(\s*(\d+)\s*\)\s*/g,"($1)"),t.colors=t.colors.replace(/([A-Z][a-z]*)\s*(\(\d+\))?[:]\s*(#[a-fA-F0-9]*)\s*/g,"$1$2:$3 "),t.colors.split(" ").filter(e=>e).forEach(function(e){let t=e.split(":")[0],s=null;t.includes("(")&&(s=Number(t.split("(")[1].replace(")","")),t=t.split("(")[0]);let r=e.split(":")[1];if(!a.colors[t]){if(r=a.addColor(Color.fromHex(r)),!/^[A-Z][a-z]*$/.test(t))throw{name:"SyntaxError",message:`Invalid color ID '${t}'.`};r.id=t,r.exId=s}},this)}static _createVoxels(e,t){let s=e.colors,a=null,r=[];if(t.matchAll)r=t.matchAll(/[0-9]+|[A-Z][a-z]*|-+|[()]/g);else{let e,s=RegExp("[0-9]+|[A-Z][a-z]*|-+|[()]","g");for(;null!==(e=s.exec(t));)console.log(e),r.push(e);r=r[Symbol.iterator]()}let i=this._unpackRle(r),o=e.size.x*e.size.y*e.size.z,l=0;for(let e=0;e<i.length;e++)l+=i[e][1];if(l!==o)throw{name:"SyntaxError",message:`The specified size is ${e.size.x} x ${e.size.y} x ${e.size.z} (= ${o} voxels) but the voxel matrix contains ${l} voxels.`};let n={minx:0,miny:0,minz:0,maxx:e.size.x-1,maxy:e.size.y-1,maxz:e.size.z-1,x:0,y:0,z:0};for(let t=0;t<i.length;t++){let r=null;"-"!==i[t][0]&&((r=s[i[t][0]])||(null===a&&(a=e.materials.createMaterial(SVOX.MATSTANDARD,SVOX.FLAT,.5,0,!1,1,!1)),(r=Color.fromHex("#FF00FF")).id=i[t][0],a.addColor(r),s[i[t][0]]=r)),this._setVoxels(e,r,i[t][1],n)}}static _parseAo(e){let t=void 0;if(e){e.startsWith("#")||(e="#000 "+e);let s=Color.fromHex(e.split(" ")[0]),a=Math.abs(parseFloat(e.split(" ")[1]||1)),r=parseFloat(e.split(" ")[2]||1),i=parseFloat(e.split(" ")[3]||70);t={color:s,maxDistance:a,strength:r,angle:i=Math.max(0,Math.min(90,Math.round(i)))}}return t}static _parseShell(e){let t=void 0,s=!1;if(e&&(t=[],"none"!==e)){let a=e.split(/\s+/);if(a.length<2||a.length%2!=0)s=!0;else for(let e=0;e<a.length/2;e++){let r=a[2*e+0],i=a[2*e+1];if(!/^[A-Z][a-z]*$/.test(r)||!/^([-+]?[0-9]*\.?[0-9]+)*$/.test(i)){s=!0;break}t.push({colorId:a[2*e],distance:a[2*e+1]})}}if(s)throw{name:"SyntaxError",message:`shell '${e}' must be 'none' or one or more color ID's and distances, e.g. P 0.2 Q 0.4`};return t&&(t=t.sort(function(e,t){return e.distance-t.distance})),t}static _resolveShellColors(e,t){e&&0!==e.length&&e.forEach(function(e){if(e.color=t.colors[e.colorId],!e.color)throw{name:"SyntaxError",message:`shell color ID '${e.colorId}' not found in one of the materials.`}},this)}static _parseXYZInt(e,t,s,a){let r=this._parseXYZFloat(e,t,s,a);return{x:Math.trunc(r.x),y:Math.trunc(r.y),z:Math.trunc(r.z)}}static _parseXYZFloat(e,t,s,a){if(!t&&s&&(t=s),!t)return null;let r=t.split(/[\s/]+/);if(1===r.length&&a&&(r.push(r[0]),r.push(r[0])),3!==r.length)throw{name:"SyntaxError",message:`'${e}' must have three values.`};if(r={x:parseFloat(r[0]),y:parseFloat(r[1]),z:parseFloat(r[2])},Number.isNaN(r.x)||Number.isNaN(r.y)||Number.isNaN(r.z))throw{name:"SyntaxError",message:`Invalid value '${t}' for ${e}'.`};return r}static _unpackRle(e){let t=[],s=1,a=e.next();for(;!a.done;){let r=a.value[0];if(r[0]>="0"&&r[0]<="9")s=parseInt(r,10);else if("("===r){let a=this._unpackRle(e);for(let e=0;e<s;e++)Array.prototype.push.apply(t,a);s=1}else{if(")"===r)return t;r.length>1&&r[0]>="A"&&r[0]<="Z"&&r[1]===r[0]?(s>1?(t.push([r[0],s]),t.push([r[0],r.length-1])):t.push([r[0],r.length]),s=1):r.length>1&&"-"===r[0]&&"-"===r[1]?(s>1?(t.push(["-",s]),t.push(["-",r.length-1])):t.push(["-",r.length]),s=1):(t.push([r,s]),s=1)}a=e.next()}return t}static _setVoxels(e,t,s,a){for(;s-- >0;)t&&e.voxels.setVoxel(a.x,a.y,a.z,new Voxel(t)),a.x++,a.x>a.maxx&&(a.x=a.minx,a.y++),a.y>a.maxy&&(a.y=a.miny,a.z++)}static _validateModel(e){this._validateProperties(e,["size","materials","textures","lights","voxels"],["name","shape","scale","rotation","position","origin","autoresize","flatten","clamp","skip","tile","ao","aosides","aosamples","shell","wireframe"],"model"),e.lights.forEach(function(e){this._validateLight(e)},this),e.textures.forEach(function(e){this._validateTexture(e)},this),e.materials.forEach(function(e){this._validateMaterial(e)},this)}static _validateLight(e){if(this._validateProperties(e,["color"],["direction","position","distance","size","detail"],"light"),e.direction&&e.position)throw{name:"SyntaxError",message:"A light cannot have a 'position' as well as a 'direction'."};if(e.direction&&e.distance)throw{name:"SyntaxError",message:"A directional light cannot have a 'distance'."};if(!e.position&&(e.size||e.detail))throw{name:"SyntaxError",message:"Only positional lights can have size and detail."}}static _validateTexture(e){this._validateProperties(e,["id","image"],["cube"],"texture")}static _validateMaterial(e){this._validateProperties(e,["colors"],["type","lighting","fade","roughness","metalness","emissive","fog","opacity","alphatest","transparent","deform","warp","scatter","flatten","clamp","skip","ao","lights","wireframe","side","shell","map","normalmap","roughnessmap","metalnessmap","emissivemap","matcap","maptransform"],"material")}static _validateProperties(e,t,s,a){for(let s of t)if(!e[s])throw{name:"SyntaxError",message:`Mandatory property '${s}' not set in ${a}.`};for(let r in e)if(!t.includes(r)&&!s.includes(r))throw{name:"SyntaxError",message:`Unknown property '${r}' found in ${a}.`}}}class ModelWriter{static writeToString(e,t,s){s=Math.round(s||1),e.prepareForWrite();let a=!1,r=[];if(e.materials.forEach(function(e){e.colors.forEach(function(e){r.push(e),e.id||(a=!0)})}),a){r.sort(function(e,t){return t.count-e.count});for(let e=0;e<r.length;e++)r[e].id=this._colorIdForIndex(e)}let i=this._serializeTextures(e);i+=this._serializeLights(e),i+="model\r\n";let o=e.voxels.bounds.size;return o.y===o.x&&o.z===o.x?i+=`size = ${o.x*s}\r\n`:i+=`size = ${o.x*s} ${o.y*s} ${o.z*s}\r\n`,"box"!==e.shape&&(i+=`shape = ${e.shape}\r\n`),1===e.scale.x&&1===e.scale.y&&1===e.scale.z&&1===s||(e.scale.y===e.scale.x&&e.scale.z===e.scale.x?i+=`scale = ${e.scale.x/s}\r\n`:i+=`scale = ${e.scale.x/s} ${e.scale.y/s} ${e.scale.z/s}\r\n`),e.autoResize&&(i+="autoresize = true\r\n"),0===e.rotation.x&&0===e.rotation.y&&0===e.rotation.z||(i+=`rotation = ${e.rotation.x} ${e.rotation.y} ${e.rotation.z}\r\n`),0===e.position.x&&0===e.position.y&&0===e.position.z||(i+=`position = ${e.position.x} ${e.position.y} ${e.position.z}\r\n`),e.origin&&(i+=`origin = ${e.origin}\r\n`),e.flatten&&(i+=`flatten = ${e.flatten}\r\n`),e.clamp&&(i+=`clamp = ${e.clamp}\r\n`),e.skip&&(i+=`skip = ${e.skip}\r\n`),e.tile&&(i+=`tile = ${e.tile}\r\n`),e.ao&&(i+=`ao =${"#000"!==e.ao.color.toString()?" "+e.ao.color:""} ${e.ao.maxDistance} ${e.ao.strength}${70!==e.ao.angle?" "+e.ao.angle:""}\r\n`),e.asSides&&(i+=`aosides = ${e.aoSides}\r\n`),e.asSamples&&(i+=`aosamples = ${e.aoSamples}\r\n`),e.wireframe&&(i+="wireframe = true\r\n"),e.shell&&(i+=`shell = ${this._getShell(e.shell)}\r\n`),i+=this._serializeMaterials(e),i+=t&&1===s?this._serializeVoxelsRLE(e,100):this._serializeVoxels(e,s)}static _serializeTextures(e){let t="",s="";return Object.getOwnPropertyNames(e.textures).forEach(function(a){let r=e.textures[a],i=[];i.push(`id = ${r.id}`),r.cube&&i.push("cube = true"),i.push(`image = ${r.image}`),t+=`texture ${i.join(", ")}\r\n`,s="\r\n"}),t+=s}static _serializeLights(e){let t="",s="";return e.lights.forEach(function(e){let a=[],r=`${e.color}`;1!==e.strength&&(r+=` ${e.strength}`),a.push(`color = ${r}`),e.direction&&a.push(`direction = ${e.direction.x} ${e.direction.y} ${e.direction.z}`),e.position&&a.push(`position = ${e.position.x} ${e.position.y} ${e.position.z}`),e.distance&&a.push(`distance = ${e.distance}`),e.size&&(a.push(`size = ${e.size}`),1!==e.detail&&a.push(`detail = ${e.detail}`)),t+=`light ${a.join(", ")}\r\n`,s="\r\n"}),t+=s}static _serializeMaterials(e){let t="";return e.materials.forEach(function(s){if(0===s.colors.length)return;let a=[];if(s.type!==SVOX.MATSTANDARD&&a.push(`type = ${s.type}`),s.lighting!==SVOX.fLAT&&a.push(`lighting = ${s.lighting}`),s.wireframe&&a.push("wireframe = true"),1!==s.roughness&&a.push(`roughness = ${s.roughness}`),0!==s.metalness&&a.push(`metalness = ${s.metalness}`),s.fade&&a.push("fade = true"),1!==s.opacity&&a.push(`opacity = ${s.opacity}`),s.transparent&&a.push("transparent = true"),s.emissive&&a.push(`emissive = ${s.emissive.color} ${s.emissive.intensity}`),s.fog||a.push("fog = false"),s.side!==SVOX.FRONT&&a.push(`side = ${s.side}`),s.deform&&a.push(`deform = ${s.deform.count} ${s.deform.strength}${1!==s.deform.damping?" "+s.deform.damping:""}`),s.warp&&a.push(`warp = ${s.warp.amplitude} ${s.warp.frequency}`),s.scatter&&a.push(`scatter = ${s.scatter}`),s.ao&&a.push(`ao =${"#000"!==s.ao.color?" "+s.ao.color:""} ${s.ao.maxDistance} ${s.ao.strength}${70!==s.ao.angle?" "+s.ao.angle:""}`),e.lights.length>0&&!s.lights&&a.push("lights = false"),s.flatten&&a.push(`flatten = ${s.flatten}`),s.clamp&&a.push(`clamp = ${s.clamp}`),s.skip&&a.push(`skip = ${s.skip}`),s.map&&a.push(`map = ${s.map.id}`),s.normalMap&&a.push(`normalmap = ${s.normalMap.id}`),s.roughnessMap&&a.push(`roughnessmap = ${s.roughnessMap.id}`),s.metalnessMap&&a.push(`metalnessmap = ${s.metalnessMap.id}`),s.emissiveMap&&a.push(`emissivemap = ${s.emissiveMap.id}`),s.matcap&&a.push(`matcap = ${s.matcap.id}`),-1!==s.mapTransform.uscale||-1!==s.mapTransform.vscale){let e="maptransform =";e+=` ${s.mapTransform.uscale} ${s.mapTransform.vscale}`,0===s.mapTransform.uoffset&&0===s.mapTransform.voffset&&0===s.mapTransform.rotation||(e+=` ${s.mapTransform.uoffset} ${s.mapTransform.voffset}`,0!==s.mapTransform.rotation&&(e+=` ${s.mapTransform.rotation}`)),a.push(e)}s.shell&&a.push(`shell = ${this._getShell(s.shell)}`),t+="material "+a.join(", ")+"\r\n",t+="  colors =",s.colors.forEach(function(e){t+=` ${e.id}${null==e.exId?"":"("+e.exId+")"}:${e}`}),t+="\r\n"},this),t}static _colorIdForIndex(e){let t="ABCDEFGHIJKLMNOPQRSTUVWXYZ",s="";do{let a=e%26;s=t[a]+s.toLowerCase(),(e=(e-a)/26)<26&&(t="#ABCDEFGHIJKLMNOPQRSTUVWXYZ")}while(e>0);return s}static _getShell(e){if(0===e.length)return"none";let t="";for(let s=0;s<e.length;s++)t+=`${e[s].colorId} ${e[s].distance} `;return t.trim()}static _serializeVoxels(e,t){let s="voxels =\r\n",a=e.voxels;for(let e=a.minZ;e<=a.maxZ;e++)for(let r=0;r<t;r++){for(let r=a.minY;r<=a.maxY;r++)for(let i=0;i<t;i++){for(let i=a.minX;i<=a.maxX;i++){let o=a.getVoxel(i,r,e);for(let e=0;e<t;e++)s+=o?o.color.id:"-"}s+=" "}s+="\r\n"}return s}static _serializeVoxelsRLE(e,t){let s=[],a=0,r=void 0;e.voxels.forEachInBoundary(function(e){let i=e?e.color:null;i===r?a++:(this._addRleChunk(s,r,a,t),r=i,a=1)},this),this._addRleChunk(s,r,a,t);let i="";for(const e of s)i+=this._rleToString(e);return"voxels =\r\n"+i+"\r\n"}static _addRleChunk(e,t,s,a){if(0===s)return;let r=s>1?s.toString():"";r+=t?t.id:"-",e.push([r,1,r]);for(let t=Math.max(0,e.length-2*a);t<=e.length-2;t++){let s=e[t][0];for(let s=1;s<a&&!(t+2*s>e.length);s++){let a=!0;for(let r=0;r<=s-1&&(a=e[t+r][2]===e[t+r+s][2]);r++);if(a){let a=e.splice(t,s);e.splice(t,s-1),e[t]=[a,2,null],e[t][2]=JSON.stringify(e[t]),t=e.length;break}}if(Array.isArray(s)&&e.length>t+s.length){let a=s,r=!0;for(let s=0;s<a.length&&(r=a[s][2]===e[t+1+s][2]);s++);r&&(e.splice(t+1,a.length),e[t][1]++,e[t][2]=null,e[t][2]=JSON.stringify(e[t]),t=e.length)}}}static _rleToString(e){let t=1===e[1]?"":e[1].toString(),s=e[0];if(Array.isArray(s)){t+="(";for(let e of s)t+=this._rleToString(e);t+=")"}else t+=s;return t}}class SvoxMeshGenerator{static generate(e){let t={materials:[],groups:[],positions:[],normals:[],colors:[],uvs:null};e.prepareForRender();let s=!1;return e.materials.baseMaterials.forEach(function(a){a.colorUsageCount>0&&(a.index=t.materials.length,t.materials.push(SvoxMeshGenerator._generateMaterial(a,e)),s=s||a.map||a.normalMap||a.roughnessMap||a.metalnessMap||a.emissiveMap)},this),s&&(t.uvs=[]),SvoxMeshGenerator._generateAll(e,t),SvoxMeshGenerator._generateLights(e,t),t}static _generateMaterial(e,t){e.ao||t.ao;let s={type:e.type,roughness:e.roughness,metalness:e.metalness,opacity:e.opacity,alphaTest:e.alphaTest,transparent:e.isTransparent,wireframe:e.wireframe||t.wireframe,fog:e.fog,vertexColors:"FaceColors",side:e.side===SVOX.DOUBLE?SVOX.DOUBLE:SVOX.FRONT};return e.type!==SVOX.MATNORMAL&&(s.vertexColors="VertexColors",s.color="#FFF"),e.emissive&&(s.emissive=e.emissive.color.toString(),s.emissiveIntensity=e.emissive.intensity),e.map&&(s.map={image:e.map.image,uscale:-1===e.mapTransform.uscale?1:e.mapTransform.uscale,vscale:-1===e.mapTransform.vscale?1:e.mapTransform.vscale,uoffset:e.mapTransform.uoffset,voffset:e.mapTransform.voffset,rotation:e.mapTransform.rotation}),e.normalMap&&(s.normalMap={image:e.normalMap.image,uscale:-1===e.mapTransform.uscale?1:e.mapTransform.uscale,vscale:-1===e.mapTransform.vscale?1:e.mapTransform.vscale,uoffset:e.mapTransform.uoffset,voffset:e.mapTransform.voffset,rotation:e.mapTransform.rotation}),e.roughnessMap&&(s.roughnessMap={image:e.roughnessMap.image,uscale:-1===e.mapTransform.uscale?1:e.mapTransform.uscale,vscale:-1===e.mapTransform.vscale?1:e.mapTransform.vscale,uoffset:e.mapTransform.uoffset,voffset:e.mapTransform.voffset,rotation:e.mapTransform.rotation}),e.metalnessMap&&(s.metalnessMap={image:e.metalnessMap.image,uscale:-1===e.mapTransform.uscale?1:e.mapTransform.uscale,vscale:-1===e.mapTransform.vscale?1:e.mapTransform.vscale,uoffset:e.mapTransform.uoffset,voffset:e.mapTransform.voffset,rotation:e.mapTransform.rotation}),e.emissiveMap&&(s.emissiveMap={image:e.emissiveMap.image,uscale:-1===e.mapTransform.uscale?1:e.mapTransform.uscale,vscale:-1===e.mapTransform.vscale?1:e.mapTransform.vscale,uoffset:e.mapTransform.uoffset,voffset:e.mapTransform.voffset,rotation:e.mapTransform.rotation}),e.matcap&&(s.matcap={image:e.matcap.image}),s}static _generateAll(e,t){let s=SvoxMeshGenerator._getAllShells(e);e.materials.baseMaterials.forEach(function(a){if(a.colorUsageCount>0){let r=t.positions.length;e.voxels.forEach(function(r){r.material.index===a.index&&SvoxMeshGenerator._generateVoxel(e,r,t),s.forEach(function(s){s.shellMaterialIndex===a.index&&s.voxelMaterial===r.color.material&&SvoxMeshGenerator._generateVoxelShell(e,r,t,s.distance,s.color)},this)},this);let i=t.positions.length;t.groups.push({start:r/3,count:(i-r)/3,materialIndex:a.index})}},this)}static _generateVoxels(e,t){e.materials.baseMaterials.forEach(function(s){if(s.colorUsageCount>0){let a=t.positions.length;e.voxels.forEach(function(a){a.material.index===s.index&&SvoxMeshGenerator._generateVoxel(e,a,t)},this);let r=t.positions.length;t.groups.push({start:a/3,count:(r-a)/3,materialIndex:s.index})}},this)}static _generateVoxel(e,t,s){for(let a=0;a<SVOX._FACES.length;a++){let r=t.faces[SVOX._FACES[a]];r&&!r.skipped&&SvoxMeshGenerator._generateVoxelFace(e,t,r,s)}}static _generateVoxelFace(e,t,s,a){let r,i,o,l,n,m,h,c,u,x,p,f,g,y,d,v;if(r=s.vertices[0],i=s.vertices[1],o=s.vertices[2],l=s.vertices[3],n=s.normals[0],m=s.normals[1],h=s.normals[2],c=s.normals[3],s.vertexColors&&(u=s.vertexColors[0],x=s.vertexColors[1],p=s.vertexColors[2],f=s.vertexColors[3]),a.uvs&&(g=s.uv[0]||{u:0,v:0},y=s.uv[1]||{u:0,v:0},d=s.uv[2]||{u:0,v:0},v=s.uv[3]||{u:0,v:0}),"back"===t.color.material.side){let e;e=r,r=o,o=e,e=n,n=h,h=e,e=u,u=p,p=e,e=g,g=d,d=e}if(s.vertexColors&&SVOX.clampColors&&(SvoxMeshGenerator._clampColor(u),SvoxMeshGenerator._clampColor(x),SvoxMeshGenerator._clampColor(p),SvoxMeshGenerator._clampColor(f)),a.positions.push(o.x,o.y,o.z),a.positions.push(i.x,i.y,i.z),a.positions.push(r.x,r.y,r.z),a.positions.push(r.x,r.y,r.z),a.positions.push(l.x,l.y,l.z),a.positions.push(o.x,o.y,o.z),t.material.lighting===SVOX.FLAT){let e=s.normals[1],t=s.normals[3];a.normals.push(e.x,e.y,e.z),a.normals.push(e.x,e.y,e.z),a.normals.push(e.x,e.y,e.z),a.normals.push(t.x,t.y,t.z),a.normals.push(t.x,t.y,t.z),a.normals.push(t.x,t.y,t.z)}else a.normals.push(h.x,h.y,h.z),a.normals.push(m.x,m.y,m.z),a.normals.push(n.x,n.y,n.z),a.normals.push(n.x,n.y,n.z),a.normals.push(c.x,c.y,c.z),a.normals.push(h.x,h.y,h.z);if(s.vertexColors)a.colors.push(p.r,p.g,p.b),a.colors.push(x.r,x.g,x.b),a.colors.push(u.r,u.g,u.b),a.colors.push(u.r,u.g,u.b),a.colors.push(f.r,f.g,f.b),a.colors.push(p.r,p.g,p.b);else if(s.color)for(let e=0;e<6;e++)a.colors.push(s.color.r,s.color.g,s.color.b);else{let e=t.color;for(let t=0;t<6;t++)a.colors.push(e.r,e.g,e.b)}a.uvs&&(a.uvs.push(d.u,d.v),a.uvs.push(y.u,y.v),a.uvs.push(g.u,g.v),a.uvs.push(g.u,g.v),a.uvs.push(v.u,v.v),a.uvs.push(d.u,d.v))}static _clampColor(e){e.r=Math.max(Math.min(e.r,1),0),e.g=Math.max(Math.min(e.g,1),0),e.b=Math.max(Math.min(e.b,1),0)}static _generateLights(e,t){if(e.lights.some(e=>e.size)){let s={x:0,y:1,z:0},a={x:0,y:0,z:-1},r={x:1,y:0,z:0},i={x:0,y:0,z:1},o={x:-1,y:0,z:0},l={x:0,y:-1,z:0},n=t.positions.length;e.lights.filter(e=>e.position).forEach(function(e){if(e.size>0){let n=e.size/2,m=e.detail;SvoxMeshGenerator._createLightFace(e.position,e.color,n,m,a,r,s,t),SvoxMeshGenerator._createLightFace(e.position,e.color,n,m,r,i,s,t),SvoxMeshGenerator._createLightFace(e.position,e.color,n,m,i,o,s,t),SvoxMeshGenerator._createLightFace(e.position,e.color,n,m,o,a,s,t),SvoxMeshGenerator._createLightFace(e.position,e.color,n,m,a,l,r,t),SvoxMeshGenerator._createLightFace(e.position,e.color,n,m,r,l,i,t),SvoxMeshGenerator._createLightFace(e.position,e.color,n,m,i,l,o,t),SvoxMeshGenerator._createLightFace(e.position,e.color,n,m,o,l,a,t)}});let m=t.positions.length;t.groups.push({start:n/3,count:(m-n)/3,materialIndex:0})}}static _createLightFace(e,t,s,a,r,i,o,l){if(0===a)l.positions.push(e.x+o.x*s,e.y+o.y*s,e.z+o.z*s),l.positions.push(e.x+i.x*s,e.y+i.y*s,e.z+i.z*s),l.positions.push(e.x+r.x*s,e.y+r.y*s,e.z+r.z*s),l.normals.push(0,0,1),l.normals.push(0,0,1),l.normals.push(0,0,1),l.colors.push(t.r,t.g,t.b),l.colors.push(t.r,t.g,t.b),l.colors.push(t.r,t.g,t.b),l.uvs&&(l.uvs.push(0,0),l.uvs.push(0,0),l.uvs.push(0,0));else{let n=SvoxMeshGenerator._normalize({x:(i.x+r.x)/2,y:(i.y+r.y)/2,z:(i.z+r.z)/2}),m=SvoxMeshGenerator._normalize({x:(i.x+o.x)/2,y:(i.y+o.y)/2,z:(i.z+o.z)/2}),h=SvoxMeshGenerator._normalize({x:(r.x+o.x)/2,y:(r.y+o.y)/2,z:(r.z+o.z)/2});SvoxMeshGenerator._createLightFace(e,t,s,a-1,n,i,m,l),SvoxMeshGenerator._createLightFace(e,t,s,a-1,r,n,h,l),SvoxMeshGenerator._createLightFace(e,t,s,a-1,h,m,o,l),SvoxMeshGenerator._createLightFace(e,t,s,a-1,n,m,h,l)}}static _getAllShells(e){let t=[];return e.materials.forEach(function(s){let a=void 0;e.shell&&e.shell.length>0&&!s.shell&&(a=e.shell),s.shell&&s.shell.length>0&&(a=s.shell),a&&a.forEach(function(e){t.push({voxelMaterial:s,shellMaterialIndex:e.color.material.index,color:e.color,distance:e.distance})},this)},this),t.sort(function(e,t){e.shellMaterialIndex,t.shellMaterialIndex}),t}static _generateShells(e,t){SvoxMeshGenerator._getAllShells(e).forEach(function(s){let a=t.positions.length;e.voxels.forEach(function(a){a.color.material===s.voxelMaterial&&SvoxMeshGenerator._generateVoxelShell(e,a,t,s.distance,s.color)},this);let r=t.positions.length;t.groups.push({start:a/3,count:(r-a)/3,materialIndex:s.shellMaterialIndex})})}static _generateVoxelShell(e,t,s,a,r){for(let i=0;i<SVOX._FACES.length;i++){let o=t.faces[SVOX._FACES[i]];o&&!o.skipped&&SvoxMeshGenerator._generateVoxelShellFace(e,t,o,s,a,r)}}static _generateVoxelShellFace(e,t,s,a,r,i){let o,l,n,m,h,c,u,x,p,f,g,y,d,v;if(o=s.vertices[0],l=s.vertices[1],n=s.vertices[2],m=s.vertices[3],h=o.averageNormal,c=l.averageNormal,u=n.averageNormal,x=m.averageNormal,a.uvs&&(g=s.uv[0]||{u:1e-4,v:1e-4},y=s.uv[1]||{u:1e-4,v:.9999},d=s.uv[2]||{u:.9999,v:.9999},v=s.uv[3]||{u:.9999,v:1e-4}),"back"===i.material.side){let e;e=o,o=n,n=e,e=h,h=u,u=e,e=p,p=f,f=e,e=g,g=d,d=e}o={x:o.x+h.x*r*e.scale.x,y:o.y+h.y*r*e.scale.y,z:o.z+h.z*r*e.scale.z},l={x:l.x+c.x*r*e.scale.x,y:l.y+c.y*r*e.scale.y,z:l.z+c.z*r*e.scale.z},n={x:n.x+u.x*r*e.scale.x,y:n.y+u.y*r*e.scale.y,z:n.z+u.z*r*e.scale.z},m={x:m.x+x.x*r*e.scale.x,y:m.y+x.y*r*e.scale.y,z:m.z+x.z*r*e.scale.z},a.positions.push(n.x,n.y,n.z),a.positions.push(l.x,l.y,l.z),a.positions.push(o.x,o.y,o.z),a.positions.push(o.x,o.y,o.z),a.positions.push(m.x,m.y,m.z),a.positions.push(n.x,n.y,n.z),a.normals.push(u.x,u.y,u.z),a.normals.push(c.x,c.y,c.z),a.normals.push(h.x,h.y,h.z),a.normals.push(h.x,h.y,h.z),a.normals.push(x.x,x.y,x.z),a.normals.push(u.x,u.y,u.z);for(let e=0;e<6;e++)a.colors.push(i.r,i.g,i.b);a.uvs&&(a.uvs.push(d.u,d.v),a.uvs.push(y.u,y.v),a.uvs.push(g.u,g.v),a.uvs.push(g.u,g.v),a.uvs.push(v.u,v.v),a.uvs.push(d.u,d.v))}static _normalize(e){let t=Math.sqrt(e.x*e.x+e.y*e.y+e.z*e.z);return e.x/=t,e.y/=t,e.z/=t,e}}class SvoxToThreeMeshConverter{static generate(e){let t=[];e.materials.forEach(function(e){t.push(SvoxToThreeMeshConverter._generateMaterial(e))},this);let s=new THREE.BufferGeometry;s.setAttribute("position",new THREE.Float32BufferAttribute(e.positions,3)),s.setAttribute("normal",new THREE.Float32BufferAttribute(e.normals,3)),s.setAttribute("color",new THREE.Float32BufferAttribute(e.colors,3)),e.uvs&&s.setAttribute("uv",new THREE.Float32BufferAttribute(e.uvs,2));let a=[];for(let t=0;t<e.positions.length/3;t++)a.push(t);return s.setIndex(a),e.groups.forEach(function(e){s.addGroup(e.start,e.count,e.materialIndex)},this),s.computeBoundingBox(),s.uvsNeedUpdate=!0,new THREE.Mesh(s,t)}static _generateMaterial(e){switch("standard"!==e.type&&(delete e.roughness,delete e.metalness),delete e.index,"matcap"===e.type&&delete e.wireframe,"basic"!==e.type&&"lambert"!==e.type&&"phong"!==e.type||(e.reflectivity=1-e.roughness),e.side){case"back":e.side=THREE.BackSide;break;case"double":e.side=THREE.DoubleSide;break;default:e.side=THREE.FrontSide}e.map&&(e.map=SvoxToThreeMeshConverter._generateTexture(e.map.image,THREE.sRGBEncoding,e.map.uscale,e.map.vscale,e.map.uoffset,e.map.voffset,e.map.rotation)),e.normalMap&&(e.normalMap=SvoxToThreeMeshConverter._generateTexture(e.normalMap.image,THREE.LinearEncoding,e.normalMap.uscale,e.normalMap.vscale,e.normalMap.uoffset,e.normalMap.voffset,e.normalMap.rotation)),e.roughnessMap&&(e.roughnessMap=SvoxToThreeMeshConverter._generateTexture(e.roughnessMap.image,THREE.LinearEncoding,e.roughnessMap.uscale,e.roughnessMap.vscale,e.roughnessMap.uoffset,e.roughnessMap.voffset,e.roughnessMap.rotation)),e.metalnessMap&&(e.metalnessMap=SvoxToThreeMeshConverter._generateTexture(e.metalnessMap.image,THREE.LinearEncoding,e.metalnessMap.uscale,e.metalnessMap.vscale,e.metalnessMap.uoffset,e.metalnessMap.voffset,e.metalnessMap.rotation)),e.emissiveMap&&(e.emissiveMap=SvoxToThreeMeshConverter._generateTexture(e.emissiveMap.image,THREE.sRGBEncoding,e.emissiveMap.uscale,e.emissiveMap.vscale,e.emissiveMap.uoffset,e.emissiveMap.voffset,e.emissiveMap.rotation)),e.matcap&&(e.matcap=SvoxToThreeMeshConverter._generateTexture(e.matcap.image,THREE.sRGBEncoding));let t=null,s=e.type;switch(delete e.type,s){case"standard":t=new THREE.MeshStandardMaterial(e);break;case"basic":t=new THREE.MeshBasicMaterial(e);break;case"lambert":t=new THREE.MeshLambertMaterial(e);break;case"phong":t=new THREE.MeshPhongMaterial(e);break;case"matcap":t=new THREE.MeshMatcapMaterial(e);break;case"toon":t=new THREE.MeshToonMaterial(e);break;case"normal":t=new THREE.MeshNormalMaterial(e);break;default:throw{name:"SyntaxError",message:`Unknown material type '${s}'.`}}return t}static _generateTexture(e,t,s,a,r,i,o){let l=(new THREE.TextureLoader).load(e);return l.encoding=t,l.repeat.set(1/s,1/a),l.wrapS=THREE.RepeatWrapping,l.wrapT=THREE.RepeatWrapping,l.offset=new THREE.Vector2(r,i),l.rotation=o*Math.PI/180,l}}class WorkerPool{constructor(e,t,s){this._workerFile=e,this._resultHandler=t,this._resultCallback=s,this._nrOfWorkers=window.navigator.hardwareConcurrency,this._workers=[],this._free=[],this._tasks=[]}executeTask(e){if(this._workers.length<this._nrOfWorkers){let e=new Worker(this._workerFile),t=this;e.onmessage=function(e){t._free.push(event.data.worker),t._processNextTask(),t._resultCallback.apply(t._resultHandler,[event.data])},this._free.push(this._workers.length),this._workers.push(e)}this._tasks.push(e),this._processNextTask()}_processNextTask(){if(this._tasks.length>0&&this._free.length>0){let e=this._tasks.shift();e.worker=this._free.shift(),this._workers[e.worker].postMessage(e)}}}if("undefined"!=typeof window){if("undefined"==typeof AFRAME)throw new Error("Component attempted to register before AFRAME was available.");SVOX.WORKERPOOL=null,AFRAME.registerComponent("svox",{schema:{model:{type:"string"},worker:{type:"boolean",default:!1}},multiple:!1,_MISSING:"model size=9,scale=0.05,material lighting=flat,colors=A:#FFFFFF B:#FF8800 C:#FF0000,voxels 10B7-2B-C3-C-2B2-C-C2-2B3-C3-2B2-C-C2-2B-C3-C-2B7-11B7-B-6(7A2-)7A-B7-2B-C3-C-B-7A-C7AC-2(7A2-)7A-C7AC-7A-B-C3-C-2B2-C-C2-B-7A2-2(7A-C7AC-)7A2-7A-B2-C-C2-2B3-C3-B-2(7A2-)7A-C7AC-2(7A2-)7A-B3-C3-2B2-C-C2-B-7A2-2(7A-C7AC-)7A2-7A-B2-C-C2-2B-C3-C-B-7A-C7AC-2(7A2-)7A-C7AC-7A-B-C3-C-2B7-B-6(7A2-)7A-B7-11B7-2B-C3-C-2B2-C-C2-2B3-C3-2B2-C-C2-2B-C3-C-2B7-10B",_ERROR:"model size=9,scale=0.05,material lighting=flat,colors=B:#FF8800 C:#FF0000 A:#FFFFFF,voxels 10B7-2(2B2-3C2-2B4-C2-)2B2-3C2-2B7-11B7-B-6(7A2-)7A-B7-2B2-3C2-B-6(7A2-)7A-B2-3C2-2B2-C4-B-2(7A-C7A2C)7A-C7AC-7A-B2-C4-2B2-3C2-B3(-7A-C7AC)-7A-B2-3C2-2B2-C4-B-7A-C2(7AC-7A2C)7AC-7A-B2-C4-2B2-3C2-B-6(7A2-)7A-B2-3C2-2B7-B-6(7A2-)7A-B7-11B7-2(2B2-3C2-2B2-C4-)2B2-3C2-2B7-10B",_workerPool:null,init:function(){let e=this.el,t=this.data,s=t.worker,a=!1,r=t.model,i=SVOX.models[r];i||(this._logError(t.model,{name:"ConfigError",message:"Model not found"}),i=this._MISSING,a=!0,s=!1),s?this._generateModelInWorker(i,e):this._generateModel(i,e,a)},_generateModel:function(e,t,s){let a,r=performance.now();try{a=ModelReader.readFromString(e)}catch(e){this._logError(e),a=ModelReader.readFromString(this._ERROR),s=!0}try{let e=SvoxMeshGenerator.generate(a);this.mesh=SvoxToThreeMeshConverter.generate(e);let i=performance.now(),o=`Time: ${Math.round(i-r)}ms. Verts:${this.mesh.geometry.attributes.position.count} Faces:${this.mesh.geometry.attributes.position.count/3} Materials:${this.mesh.material.length}`,l=document.getElementById("svoxstats");l&&!s&&(l.innerHTML="Last render: "+o),t.setObject3D("mesh",this.mesh)}catch(s){this._logError(s)}},_generateModelInWorker:function(e,t){t.id||(t.id=(new Date).valueOf().toString(36)+Math.random().toString(36).substr(2));let s={svoxmodel:e,elementId:t.id};SVOX.WORKERPOOL||(SVOX.WORKERPOOL=new WorkerPool("/smoothvoxelworker.1.1.0.js",this,this._processResult)),SVOX.WORKERPOOL.executeTask(s)},_processResult:function(e){if(e.svoxmesh.error)this._logError(e.svoxmesh.error);else{let t=SvoxToThreeMeshConverter.generate(e.svoxmesh);document.querySelector("#"+e.elementId).setObject3D("mesh",t)}},_toSharedArrayBuffer(e){let t=new Float32Array(new ArrayBuffer(4*e.length));return t.set(e,0),t},_logError:function(e){let t=e.name+": "+e.message,s=document.getElementById("svoxerrors");s&&(s.innerHTML=t),console.error(`SVOXERROR (${this.data.model}) ${t}`)},update:function(e){},remove:function(){let e=["map","normalMap","roughnessMap","metalnessMap","emissiveMap","matcap"];if(this.mesh){for(;this.mesh.material.length>0;)e.forEach(function(e){this.mesh.material[0][e]&&this.mesh.material[0][e].dispose},this),this.mesh.material[0].dispose(),this.mesh.material.shift();this.mesh.geometry.dispose(),this.el.removeObject3D("mesh"),delete this.mesh}},pause:function(){},play:function(){},events:{}})}